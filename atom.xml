<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zjy98.github.io</id>
    <title>给敦敦买炸猪排</title>
    <updated>2020-05-24T17:40:57.426Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zjy98.github.io"/>
    <link rel="self" href="https://zjy98.github.io/atom.xml"/>
    <subtitle>LOVE YOURSELF</subtitle>
    <logo>https://zjy98.github.io/images/avatar.png</logo>
    <icon>https://zjy98.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 给敦敦买炸猪排</rights>
    <entry>
        <title type="html"><![CDATA[本周计划]]></title>
        <id>https://zjy98.github.io/post/ben-zhou-ji-hua/</id>
        <link href="https://zjy98.github.io/post/ben-zhou-ji-hua/">
        </link>
        <updated>2020-05-24T17:34:58.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>交换原理的的课看完，作业写了（周一）</li>
<li>计算机系统结构实验（周一/周二上午写了）</li>
<li>机器学习实验3（周五前写完）</li>
<li>Linux课看完，实验写了（周四周五周六周日）</li>
<li>软工再继续写，能收发消息！（看情况周日前）</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进程的创建和重定向]]></title>
        <id>https://zjy98.github.io/post/jin-cheng-de-chuang-jian-he-chong-ding-xiang/</id>
        <link href="https://zjy98.github.io/post/jin-cheng-de-chuang-jian-he-chong-ding-xiang/">
        </link>
        <updated>2020-05-21T16:16:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="进程的生命周期从生到死">进程的生命周期：从生到死</h1>
<p>程序运行起来：产生了一个进程。<br>
<img src="https://zjy98.github.io/post-images/1590077907649.png" alt="" loading="lazy"></p>
<h2 id="fork创建新进程">fork:创建新进程</h2>
<ul>
<li>功能<br>
fork系统调用时创建新进程的唯一方式<br>
原先的进程叫做父进程，新进程被称作子进程<br>
完全复制：新进程的指令，用户数据段，堆栈段<br>
部分复制：系统数据段</li>
<li>fork返回值：父子进程都收到返回值，但不相同<br>
返回值很关键，它是区分父进程（返回值&gt;0是子进程的PID）和子进程（返回值=0），失败时返回-1</li>
<li>内核实现<br>
创建新的PCB，复制父进程环境（包括PCB和内存资源）给子进程<br>
父子进程可以共享程序和数据（如copy-on-write技术，COW）但是这些系统核心的安排，对程序员透明<br>
<img src="https://zjy98.github.io/post-images/1590078682173.png" alt="" loading="lazy"><br>
最后两行，可能是父进程先执行，也可能是子进程<br>
<img src="https://zjy98.github.io/post-images/1590078789026.png" alt="" loading="lazy"><br>
一边父进程，一边子进程<br>
执行fork(),两个阶段，1执行fork调用，2恢复运行 给ret赋值两个进程都要赋值<br>
父子进程有区别，父进程赋值的是大于0的值，子进程是==0的值（父子进程的程序一样）<br>
<img src="https://zjy98.github.io/post-images/1590078911802.png" alt="" loading="lazy"><br>
这个执行结果来看，子进程先结束</li>
</ul>
<p><img src="https://zjy98.github.io/post-images/1590079147167.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590079162563.png" alt="" loading="lazy"></p>
<h2 id="exec系统调用">exec系统调用</h2>
<ul>
<li>功能<br>
用一个指定的程序文件，重新初始化一个进程<br>
可指定新的命令行参数和环境参数（初始化堆栈底部）<br>
exec不创建新进程，只是将当前进程重新初始化了指令段和用户端段，堆栈段以及CPU的PC指针</li>
<li>6种格式exec系统调用<br>
exec前缀，后跟一至两个字母<br>
l-list, v-vector, e-env, p-path<br>
l与v:指定命令行参数的两种方式，l以表的形式，v要事先组织成一个指针数组<br>
e:需要指定环境变量PATH查找可执行文件<br>
p:使用环境变量PATH查找可执行文件<br>
六种格式的区别：不同的参数方式初始化堆栈底部</li>
</ul>
<h2 id="僵尸进程zombie或defunct">僵尸进程（zombie或defunct)</h2>
<ul>
<li>进程生命期结束时的特殊状态<br>
系统已经释放了进程占用的包括内存在内的系统资源，但仍在内核中保留进程的部分数据结构，记录进程的终止态，等待父进程来收尸。<br>
父进程的收尸动作完成后，僵尸进程不再存在。</li>
<li>僵尸进程占用资源很少，仅占用内核进程表资源<br>
过多的僵尸进程会导致有限地进程表用完</li>
<li>孤儿进程：父进程死了，子进程都变成1号进程的子进程</li>
</ul>
<h2 id="wait系统调用收尸">wait系统调用（收尸）</h2>
<ul>
<li>功能<br>
等待进程的子进程终止<br>
如果已有子进程终止，则立即返回<br>
<img src="https://zjy98.github.io/post-images/1590080061781.png" alt="" loading="lazy"></li>
</ul>
<h1 id="写一个简单的shell">写一个简单的shell</h1>
<h2 id="字符串库函数strtok">字符串库函数strtok</h2>
<p><img src="https://zjy98.github.io/post-images/1590337219763.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590337409218.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590337794150.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590337763764.png" alt="" loading="lazy"></p>
<h2 id="库函数system运行一个命令">库函数system：运行一个命令</h2>
<p>int system(char *string)<br>
执行字符串传递的shell命令，可使用管道符和重定向<br>
库函数system(),是利用系统调用fork,exec,wait实现的<br>
<img src="https://zjy98.github.io/post-images/1590338359341.png" alt="" loading="lazy"></p>
<h1 id="进程与文件描述符">进程与文件描述符</h1>
<h2 id="活动文件目录afd">活动文件目录AFD</h2>
<ul>
<li>磁盘文件目录（分2级）<br>
文件名，i节点</li>
<li>活动文件目录（分3级）<br>
文件描述符表FDT：每个进程一张，PCB的user结构中<br>
user结构中整型数组u_ofile记录进程打开的文件<br>
文件描述符fd是u_ofile数组的下标<br>
系统文件表SFT：整个核心一张，file结构</li>
</ul>
<pre><code class="language-c">struct file{
    char f_flag; //读写操作要求
    char f_count;//引用计数
    long f_offset;//文件读写位置指针
    int f_inode;//内核中inode数组的下标
}
</code></pre>
<p>活动i节点表：整个核心一张，inode结构<br>
内存中inode表是外存中inode的缓冲<br>
内存inode表里也有个专用的引用计数<br>
<img src="https://zjy98.github.io/post-images/1590338772959.png" alt="" loading="lazy"></p>
<h2 id="文件描述符的继承和关闭">文件描述符的继承和关闭</h2>
<p>fork创建的子进程继承父进程的文件描述符表<br>
父进程在fork前打开的文件，父子进程有相同的文件偏移<br>
<img src="https://zjy98.github.io/post-images/1590339425330.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590339445517.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590339714460.png" alt="" loading="lazy"></p>
<h1 id="重定向">重定向</h1>
<p>类似文件描述符的复制</p>
<ul>
<li>系统调用<br>
int dup2(int fd1,int fd2)</li>
<li>功能<br>
复制文件描述符fd1到fd2<br>
fd2可以是空闲的文件描述符<br>
如果fd2是已打开文件，则关闭已打开文件<br>
<img src="https://zjy98.github.io/post-images/1590339931448.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590340733716.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590340790365.png" alt="" loading="lazy"></li>
</ul>
<h1 id="错题">错题：</h1>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main(void)
{
    int i = 0;
    printf(&quot;PID=%d\n&quot;, getpid());
    for (;;) {
        if (!fork())
            return 0;
        sleep(1);
        printf(&quot;%d\n&quot;, ++i);
    }
}
</code></pre>
<p>编译链接后生成的可执行程序为foo，运行./foo得到的第一行输出为：</p>
<p>PID=7812</p>
<p>然后程序继续运行，一段时间以后，在其他终端上执行vi bar.c失败，得到的提示信息为：</p>
<p>-bash: fork: retry: Resource temporarily unavailable</p>
<p>A.<br>
**在另外一个终端上执行kill 7812之后，系统恢复正常 **</p>
<p>程序中第9行if  (!fork())应该修改为if (fork() == 0)。尽管语义相同，但可读性不好，前者容易误导别人是判断fork失败，fork失败将不创建子进程，实际上是fork成功且自身是子进程。<br>
fork()后子进程直接终止，就是产生了僵尸，但是父进程没有执行wait消除僵尸。kill是内部命令，不需要创建新的进程，Ctrl-C也不需要创建进程，所以可以把foo进程杀死，foo的所有子进程（尽管都是僵尸状态），不会成为foo的父进程的子进程，而是成为操作系统进程1的子进程，1号进程会删除僵尸子进程，系统恢复正常，可以创建新的进程。reboot和killall都是外部命令，需要启动新的进程，当僵尸进程把操作系统内核中的全部进程槽占满了之后，启动失败。<br>
如果foo进程是一个网络服务后台进程，脱离终端在后台运行，出现这样的问题，任何用户也不可能再完成登录，因为登录就需要创建shell进程，就算知道了PID连执行kill命令的机会都没有。执行关机命令的机会都没有，就麻烦了。<br>
如果foo进程是后台进程没有机会Ctrl-C，即使有一个已登录的终端，若不知道进程的PID号，ps运行不了，也没法完成kill</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PHP技术]]></title>
        <id>https://zjy98.github.io/post/php-ji-zhu/</id>
        <link href="https://zjy98.github.io/post/php-ji-zhu/">
        </link>
        <updated>2020-05-20T08:44:24.000Z</updated>
        <content type="html"><![CDATA[<p>为什么要用PHP<br>
1.PHP是脚本语言<br>
2.PHP是最流行的网站开发语言<br>
3.PHP适合做移动APP的接口<br>
4.PHP适合做服务端脚本</p>
<h1 id="apache-php-和-mysql">Apache PHP 和 Mysql</h1>
<p>Apache是一个Web服务器： 基于Http/Https/Websocket等协议对外部提供数据、文件的获取功能<br>
PHP是可编程的脚本语言： 提供基本的运算和逻辑处理的功能，可以很好的应用于Web网站功能需求的开发<br>
MySQL是一种关系型数据库： 用于存储、修改、获取和管理数据的工具，可以通过结构化查询语言（SQL）进行数据库的管理。</p>
<h2 id="apache和php">Apache和PHP</h2>
<p>Apache和PHP解释器之间的关系，是调用和被调用之间的关系，Apache主动调用PHP解释器去执行PHP脚本文件，PHP解释器被Apache调用。<br>
Apache是web服务器软件，它可以接受来自客户端的Http/Https等协议的请求，当请求的文件是PHP脚本文件时，它会调用PHP解释器去解释和执行该脚本中的内容，并将解释器返回的结果，根据对应的协议规则封装成相应格式的数据，再将数据返回给请求的客户端</p>
<h2 id="php和mysql">PHP和mysql</h2>
<p>PHP和Mysql之间的关系，也是调用和被调用的关系，PHP通过SQL语言调用Mysql进行数据库的管理功能，Mysql数据库总是被动的接受操作指令。<br>
MYSQL是小型关系数据库软件，它为可以各种软件提供数据库支持，通过PHP可以操作Mysql，同理使用其它语言也可以操作Mysql，同样PHP也可以操作其他的数据库，不一定是MYSQL。<br>
PHP如何调用Mysql数据库进行操作？ PHP与Mysql交互使用的语言规则是SQL，但是PHP和Mysql是两个独立的应用程序，想要交互必须得先建立连接，就如同浏览器访问Web服务器一样，在请求数据发送之前也需要先成功建立tcp连接。PHP脚本与Mysql建立连接的过程都是由PHP的Mysqld/PDO等驱动来完成的，这些驱动的本质都是PHP的模块，即PHP解释器可以识别的相关函数集合，一般使用C语言编写，对PHP语言来说，屏蔽了具体连接建立和数据库协议操作的详细过程，对PHP语言暴露了一些基础的接口，即PHP可以调用到的一些数据库操作函数，如连接数据库、执行数据库SQL命令、断开连接等。<br>
总而言之，PHP调用Mysql数据库的过程，通常是通过PHP的数据库驱动模块来操作的，它的本质也是一个网络数据的请求操作（遵循MySql通信协议来建立连接，使用SQL语法来执行具体操作指令）。</p>
<h2 id="搭建环境">搭建环境</h2>
<p>使用PHP程序就需要先搭建一个PHP的运行环境，PHP运行环境就是包含PHP+Apache+Mysql这三个软件的环境，还需要满足的条件就是，Apache可以调用PHP解释器来执行PHP脚本，PHP可以连接Mysql数据库来操作和管理存储的数据，当满足以上两个条件时，Apache、PHP和Mysql的运行环境就是一个完整的PHP运行环境了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进程控制与进程之间的通信]]></title>
        <id>https://zjy98.github.io/post/jin-cheng-kong-zhi-yu-jin-cheng-zhi-jian-de-tong-xin/</id>
        <link href="https://zjy98.github.io/post/jin-cheng-kong-zhi-yu-jin-cheng-zhi-jian-de-tong-xin/">
        </link>
        <updated>2020-05-17T03:19:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="进程的基本概念和逻辑内存">进程的基本概念和逻辑内存</h1>
<ul>
<li>程序<br>
指令和数据的集合<br>
存放在磁盘上的一个普通文件里<br>
文件的i节点中标位可执行，内容符合系统要求</li>
<li>进程<br>
包括指令段、用户数据段和系统数据段的执行环节<br>
（进程就是程序的一次执行）</li>
<li>进程和程序的关系<br>
程序用于初始化进程的指令段和用户数据段，初始化后，进程和初始它的程序之间无联系<br>
进程运行时磁盘上的程序文件不可修改或删除<br>
同时运行的多个进程可由同一程序初始化得到，进程之间没什么联系内核通过安排它们共享指令段甚至不同程序的进程共享函数库（动态链接）以节省内存，但这种安排对用户来说是透明的</li>
<li>进程的组成部分<br>
四部分：**  指令段、数据段，栈段和系统数据 **<br>
1.指令段：text（从可执行文件中抄来）<br>
程序的CPU指令代码，包括：主程序和子程序编译后的CPU指令代码，以及调用的库函数代码<br>
指令段的大小固定不变，只读<br>
2.用户数据段：（两个来源）程序中或malloc动态申请<br>
·全局变量，静态变量，字符串常数<br>
允许数据段增长和缩小，实现内存的动态分配<br>
系统调用sbrk()允许编程调整数据段的大小（调整单位为页）<br>
内存管理库函数：malloc(),free()<br>
3.用户栈段：（程序执行现场的一部分，保留当前指针）<br>
·程序执行所需要的栈空间，实现函数的调用<br>
用于保存子程序返回地址<br>
在函数和被调函数之间传递参数<br>
函数体内部定义的变量（静态变量除外）<br>
·main函数得到的命令行参数以及环境参数<br>
存放在栈的最底部<br>
main函数运行之前，这些部分就已经被系统初始化<br>
·栈段的动态增长与增长限制（在编译程序编译时设置参数）<br>
4.系统数据段<br>
·上述三部分在进程私有的独立的逻辑地址空间内（CPU用户态访问）<br>
·系统数据段是内核内的数据，每个进程对应一套：包括页表和进程控制块PCB<br>
<img src="https://zjy98.github.io/post-images/1589808827641.png" alt="" loading="lazy"></li>
</ul>
<p>初始化的读写型数据：int a<br>
下面三行从可执行文件中拷贝而来</p>
<p><img src="https://zjy98.github.io/post-images/1589816585649.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589817098948.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589817133888.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589817691042.png" alt="" loading="lazy"></p>
<p>进程的系统数据：<br>
在UINX内核中，含有进程的属性，包括：<br>
页表<br>
进程状态，优先级信息<br>
核心堆栈<br>
当前目录（记录了当前目录的i节点）根目录<br>
打开的文件描述符表<br>
umask值<br>
进程PID,PPID<br>
进程主的实际UID/GID,有效UID/GID<br>
进程组组号</p>
<h2 id="进程pcb被分为user结构和proc结构两部分">进程PCB被分为user结构和proc结构两部分</h2>
<ul>
<li>user结构约5000字节，&lt;sys/user.h&gt;<br>
进程运行时才需要的数据在user结构<br>
核心态堆栈占用了较多空间</li>
<li>proc结构约300字节，&lt;sys/proc.h&gt;<br>
进程不运行时也需要的管理信息存于proc结构</li>
<li>用户程序不能直接存取和修改进程的系统数据</li>
<li>系统调用可用来访问或修改这些属性<br>
chdir umask open close setpgrp getpid getppid</li>
</ul>
<h2 id="进程的基本状态">进程的基本状态</h2>
<p>3个基本状态<br>
进程创建之后，主要有运行状态和睡眠状态（也叫阻塞状态，等待状态，挂起状态等等）<br>
内核总是在分时处理运行状态的进程，而不顾那些睡眠状态 的进程<br>
睡眠状态的进程，在条件满足后转化为运行状态<br>
进程在睡眠时，不占用CPU时间<br>
在编程时，尽量不要让程序处于忙等待状态</p>
<h2 id="进程的调度">进程的调度</h2>
<p>调度优先级：<br>
内核将可运行程序按优先级调度，高优先级进程优先<br>
进程的优先级在不停的变化<br>
处于睡眠状态的进程一旦被叫醒后，被赋予高优先级，以保障人机会话操作和其他外设的响应速度<br>
优先级高：时间片短 优先级低：时间片长<br>
用户程序用nice()系统调用有限地调整优先级<br>
<img src="https://zjy98.github.io/post-images/1589818884183.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589819141064.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589819153633.png" alt="" loading="lazy"></p>
<h2 id="进程的执行时间">进程的执行时间</h2>
<p>进程占用CPU的时间，大部分处于阻塞状态<br>
<img src="https://zjy98.github.io/post-images/1589819294612.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589819539782.png" alt="" loading="lazy"></p>
<p>多任务系统中，忙等待是不可取的。浪费CPU while循环一直转<br>
<img src="https://zjy98.github.io/post-images/1589820327759.png" alt="" loading="lazy"></p>
<p>课后题：<br>
1.下段程序中变量a,b以及常数120, 250分别存放在进程的哪个内存段中？</p>
<pre><code class="language-c">static int a = 120;
void modify(void)
{
    int b;
    scanf(&quot;%d&quot;, &amp;b);
    a += b + 250;
}
</code></pre>
<p>在main函数运行前，加载程序负责初始化携带初值的可读写型变量a在数据段的初值为120，所以常数120在数据段，它和a是一回事，只是a的初始值而已，而250是编译之后指令的一个操作数，叫“立即数寻址”，也就是说250是一条指令的操作数之一，是一条指令的一部分，存放在指令段</p>
<p>2.int a[N] = { 2 };改为int a[N]<br>
局数组只要是初始化了，无论初始化了一个元素或者全部元素，编译生成可执行文件（即狭义的“程序”）时，会把这个数组的全部内容逐比特记录到可执行文件中，进程启动时分配指定大小空间并把可执行文件中记录的初值初始化它。如果数组未初始化，可执行文件里只需要记录一下这个全局变量有多大就可以了，进程启动时分配指定大小空间并清零。可以尝试把那一行修改为<br>
int a[N] = { 0 };<br>
在现代的Linux中处理得跟未赋初值一样，在早先的Unix中处理得跟有赋初值一样。显然新的处理方法更优。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[强化学习]]></title>
        <id>https://zjy98.github.io/post/qiang-hua-xue-xi/</id>
        <link href="https://zjy98.github.io/post/qiang-hua-xue-xi/">
        </link>
        <updated>2020-05-15T00:24:48.000Z</updated>
        <content type="html"><![CDATA[<p>强化学习：reinforvement learning<br>
是一种“套路”或者“形式”，它可以强化或者鼓励某个人或者某个事物以更高的可能性产生同样的行为。<br>
核心：通过某种手段影响被实验者的 行为，为了实现这个目标，实验者需要构建一个完整的实验环境，通过给与被实验者一定的观测和回报，让其产生实验者想要的结果。<br>
流程：<br>
1.在每一个时刻，环境都处于一种状态<br>
2.智能体将设法得到环境当前状态的观测值<br>
3.智能体根据观测值，结合自己历史的行为准则（一般称为策略）做出行动<br>
4.这个行动会影响环境的状态，使环境发生一定改变。</p>
<p>状态：智能体所处环境的所有信息<br>
观测值：是玩家能看到的一部分信息<br>
两者存在的差异：很多任务中玩家只能看到所处位置附近的信息，而这只占整个地图的一部分，这时状态和观测的差异会对决策产生很大影响，由于每一时刻只能观测到部分信息，玩家需要记住其他区域的信息，才能做更好的全局最优的决策。</p>
<p>特点：<br>
1.不断试错，Agent需要根据回报的多少不断调整自己的策略，从而尽可能多的获得回报<br>
2.长期回报，强化学习的任务通常需要长时间的交互，追求长期分数需要多探探索，多尝试。<br>
衡量指标：<br>
算法的效果‘就散时间’稳定性和泛化性等<br>
学习时间:由于学习和尝试相关，所以学习时间一般也看做探索的次数，如果探索次数较多，一般认为所花的时间也较长。</p>
<p>监督学习：目标是训练一个模型，使模型能根据确定的输入得到对应的输出<br>
强化学习：学习“做什么”即如何把当前的情景映射为动作，才能使得数值化的收益信号最大化。<br>
学习目标的区别：<br>
监督学习：希望模型根据指定的输入得到对应的输出<br>
强化学习：希望agent（也可以想象成模型）根据指定的状态得到使回报最大化的行动<br>
二者都是完成从一个事物到另一个事物的映射</p>
<p>目标明确性的区别：<br>
监督学习：目标更明确，输入对应的是确定的输出，一般一个输入对应一个输出<br>
强化学习：目标没有这么明确。使当前状态获得最大回报的行动可能有很多<br>
比如：俄罗斯方块: 采用监督学习进行训练，模型以每一帧游戏画面为输入，对应的输出必须是确定的； 但实际达到想要的目标的方法不止一种，强化学习更关心回报。</p>
<p>从时间维度上看，二者输出的意义不同<br>
监督学习：主要看重输入和输出的匹配程度，即使存在序列到序列的映射，我们也<br>
希望每一个时刻的输出都能和输入对应上；<br>
强化学习：目标是让回报最大化，但是在与环境交互的过程中，并不是每一个行动<br>
都会获得回报。当我们完成了一次完整的交互后，会得到一个行动序列，这个行动<br>
序列中哪些行动为回报产生了正向的贡献，哪些产生了负向的贡献，有时很难界定。<br>
强化学习和监督学习<br>
棋类游戏：游戏的目标是战胜对方（获得胜利），在得到最终结果之前，Agent可能不会得 到任何回报</p>
<p>总的来说，强化学习相比监督学习有两个优点<br>
（1）定义模型需要的约束更少，影响行动的反馈虽然不及监督学习 直接，却降低了定义问题的难度<br>
（2）更看重行动序列带来的整体回报，而不是单步行动的一致性</p>
<p>有一种学习方法的目标和强化学习一致，都是最大化长期回报，但是 学习方法和监督学习类似，收集大量的单步决策样本，并让模型学习 这些单步决策的逻辑<br>
这种方法被称为“模仿学习”（ Imitation Learning），也被称为 “行为克隆”（ Behavior Cloning），它是模仿学习的一种<br>
模仿学习在一些问题上可以获得比较好的效果，但也存在如下问题<br>
（1）如何收集满足目标的样本？我们必须在某一个领域存在一个专 家，所有的样本通过专家和环境的交互产生。<br>
（2）如何收集大量的样本？如果样本数量不够多，我们很难学习出 好的策略模型。<br>
以上三个问题都不容易解决，因此模仿学习的难度并不小，这才使得 大家把目光集中在强化学习上，希望它能够解决模仿学习无法解决的 问题</p>
<p>参考书：《强化学习精要》</p>
<p>-马尔科夫决策过程MDP<br>
-基于MDP的策略学习<br>
策略迭代，价值迭代。</p>
<p>蛇棋游戏介绍：</p>
<p><img src="https://zjy98.github.io/post-images/1589503323720.png" alt="" loading="lazy"><br>
哪些因素决定了最终获得的分数：<br>
选择什么样的骰子投掷（可由玩家决定）<br>
投掷出的数目大小（玩家无法控制，受环境的随机性控制）<br>
St表示t时刻游戏状态的观测值（棋子所在的位置），用at表示t时刻选择的手法<br>
用一条状态行动链表示<br>
{S0,a0,S1,a1....St-1,at-1,St}<br>
第一种转换由策略决定：<br>
策略是一种映射，将环境的状态值st映射到一个行动集合的概率分布<br>
π=p{at,i|{s0,a0...st}}<br>
行动：玩家根据当前的状态以某种策略选择自认为最好的行动<br>
a*t=argmaxat,ip(at,i|{s0,a0...st})</p>
<p>马尔可夫性-&gt;简化模型<br>
马尔可夫性：当前时刻选择什么行动只和当前的状态有关，和前面的状态和行动无关。<br>
<img src="https://zjy98.github.io/post-images/1590105972411.png" alt="" loading="lazy"></p>
<p>环境<br>
第二种转换由环境决定<br>
环境的状态转换：从行动到状态的转换，即玩家完成行动后，环境会受到影响并完成状态的转换<br>
假设换换符合马尔可夫性质，即下一步的状态只受前一步状态影响，不受前面的状态影响，于是状态转换就能以概率的形式表示：<br>
P(St+1|St,at)</p>
<p>马尔科夫决策过程</p>
<ul>
<li>马尔科夫表示了状态间的依赖性<br>
当前状态的取值只和前一个状态产生依赖，不和更早的状态产生联系、</li>
<li>决策表示了其中的策略将由Agent决定<br>
Agent可以通过自己的行动改变状态序列<br>
和环境中存在的随机性共同决定未来的状态</li>
<li>过程表示了时间的属性<br>
Agent行动后，环境的状态将发生改变<br>
同时时间向前推进，新的状态产生<br>
Agent将获得观测值，于是新的行动产生，然后状态再更新</li>
</ul>
<p>长期回报</p>
<ul>
<li>赢得游戏的关键-&gt;得到好的策略-&gt;最大化长期回报<br>
环境可以提供我们某一时刻t的回报（即时回报）r<br>
采取某一个行动希望最大化长期回报<img src="https://zjy98.github.io/post-images/1590106372739.png" alt="" loading="lazy"></li>
<li>存的问题1<br>
计算时间（若游戏无限循环，则无法计算）<br>
解决方法：降低未来回报对当前的影响，也就是未来的回报乘以一个打折率，这个回报就是有限地<br>
<img src="https://zjy98.github.io/post-images/1590106462377.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590106488738.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590106712909.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590107138865.png" alt="" loading="lazy"></li>
</ul>
<p><img src="https://zjy98.github.io/post-images/1590107205961.png" alt="" loading="lazy"><br>
S：100<br>
A：2（2种骰子）<br>
r:除了走到100是100其他都是-1</p>
<p><img src="https://zjy98.github.io/post-images/1590107549955.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590107575116.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590107715390.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590107797638.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590108553791.png" alt="" loading="lazy"></p>
<p><img src="https://zjy98.github.io/post-images/1590108847260.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1590108851578.png" alt="" loading="lazy"><br>
要定义好S是什么，t是什么<br>
<img src="https://zjy98.github.io/post-images/1590108984587.png" alt="" loading="lazy"></p>
<p>价值迭代法<br>
<img src="https://zjy98.github.io/post-images/1590110418499.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序笔记]]></title>
        <id>https://zjy98.github.io/post/wei-xin-xiao-cheng-xu-bi-ji/</id>
        <link href="https://zjy98.github.io/post/wei-xin-xiao-cheng-xu-bi-ji/">
        </link>
        <updated>2020-05-14T16:16:44.000Z</updated>
        <content type="html"><![CDATA[<p><strong>rpx:可以根据屏幕宽度自适应</strong>，规定屏幕宽为750rpx,在ipohne6上，屏幕宽度为375rpx,共有750个像素，则750rpx=375px=750物理像素，1rpx=0.5px=1物理像素（每个设备上换算的不一样）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[写一个简单的操作系统]]></title>
        <id>https://zjy98.github.io/post/xie-yi-ge-jian-dan-de-cao-zuo-xi-tong/</id>
        <link href="https://zjy98.github.io/post/xie-yi-ge-jian-dan-de-cao-zuo-xi-tong/">
        </link>
        <updated>2020-05-12T12:40:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-基本核心模块">一、基本核心模块</h1>
<ul>
<li>
<p>进程管理<br>
1.进程的创建、删除<br>
2.进程的基本属性：进程名、进程时间片、进程优先级<br>
3.支持进程创建与撤销功能，创建后的进程在其整个生命周期可以以PCB形式存在，每个进程用一个PCB表示。<br>
4.进程根据其执行情况在不同队列（就绪队列、阻塞队列、运行队列）间迁移<br>
5.实现单处理器进程调度功能等调度算法实现。<br>
6.管理的进程数目不少于3个，竞争使用的资源可以是CPU、内存、I/O设备等<br>
7.进程可以在初始时刻由系统创建，也可以有其他进程在运行时创建。<br>
8.能够查看各进程状态、各进程队列内容。系统在运行过程中可以显示打印各进程的状态以及有关参数的变化情况，以便观察各个进程的运行过程以及系统的管理过程<br>
9.至少支持1-2个调度算法</p>
</li>
<li>
<p>内存管理</p>
</li>
<li>
<p>文件管理<br>
1.文件的创建、删除<br>
2.文件属性的修改、有关文件目录的操作</p>
</li>
</ul>
<h1 id="二-如何开发">二、如何开发</h1>
<p>我们这次想要做的可 不是这种可执行程序，而是希望能够做到把含有操作系统的CD-ROM或软盘插入电脑，或者将操 作系统装入硬盘后，只要打开电源开关就能自动运行。 为了开发这样的操作系统，我们准备按照如下的步骤来进行。<br>
1、在windows或其他系统上编写源代码<br>
2、用C语言编译器编译源代码，生成机器语言文件<br>
3、对机器语言文件进行加工，生成软盘映像文件<br>
4、将映像文件写入磁盘，作成含操作系统的启动盘</p>
<p>所谓开发操作系统，就是想办法制作一张“含有操作系统的，能够自动启动的 磁盘” 。 这里出现的“映像文件”一词，简单地说就是软盘的备份数据。我们想要把特定的内容写入 磁盘可不是拿块磁铁来在磁盘上晃晃就可以的。所以我们要先做出备份数据，然后将这些备份数 据写入磁盘，这样才能做出符合我们要求的磁盘</p>
<h1 id="三-文件管理">三、文件管理</h1>
<h2 id="文件">文件：</h2>
<ul>
<li>文件是指记录在外存上的具有文件名的一组相关信息的集合。</li>
<li>系统运行时，以进程作为基本单位，用户输入输出时，以文件为基本单位。</li>
<li>可分为有结构文件和无结构文件两种。有结构文件是由若干个相关记录组成，而无结构文件则被看成一个字符流。</li>
<li>有结构的记录式文件<br>
文件构成：由一组相似记录(如:考生信息记录)构成。<br>
记录长度：分为定长和变长。<br>
分类（按记录的组织）：<br>
顺序文件（适用定长记录）<br>
索引文件(变长，建立一张索引表)<br>
直接/哈希文件（键值确定物理地址）</li>
<li>无结构的流式文件<br>
文件构成：由字符流构成。<br>
长度：字节为单位<br>
访问：读写指针,通过穷举搜索的方式访问.</li>
</ul>
<p>读书笔记：<br>
关于操作系统启动的最重要的一个概念就是Boot Sector，也就是引导扇区，通常指设备的第一个扇区，用于加载并转让处理器控制权给操作系统。</p>
<p>硬盘的0柱面、0磁头、1扇区称为主引导扇区，也叫主引导记录MBR，该记录占用512个字节，它用于硬盘启动时将系统控制权转给用户指定的、在分区表中登记了某个操作系统分区。MBR的内容是在硬盘分区时由分区软件写入该扇区的，MBR不属于任何一个操作系统，不随操作系统的不同而不同，即使不同，MBR也不会夹带操作系统的性质，具有公共引导的特性。但安装某些多重引导功能的软件或LINUX的LILO时有可能改写它，它先于所有的操作系统被调入内存并发挥作用，然后才将控制权交给活动主分区内的操作系统</p>
<p>MBR的功能<br>
1．扫描分区表查找活动分区；<br>
2．寻找活动分区的起始扇区；<br>
3．将活动分区的引导扇区读到内存；<br>
4．执行引导扇区的运行代码。</p>
<p>使用 nasm os.asm -o os.img 命令将汇编代码转变为一个镜像文件，然后在虚拟机中使用了。</p>
<p>在IA32下，CPU有两种工作模式：实模式和保护模式。当我们打开自己的PC，开始时CPU是工作在实模式下的，经过 某种机制之后，才进入保护模式。在保护模式下，CPU有着巨大的寻址能力，并为强大的32位操作系统提供了更好的硬件保障。</p>
<p>参考代码：<br>
支持进程工作目录 提供getcwd与chdir</p>
<p>新的syscall</p>
<p>SYS_env_set_workpath 修改工作路径<br>
新的用户程序<br>
ls 功能完善<br>
pwd 输出当前工作目录<br>
cat 接入工作目录<br>
touch 由于文件属性没啥可改的，用于创建文件<br>
mkdir 创建目录文件<br>
msh 更高级的shell 还未完全完工 支持cd 支持默认二进制路径为 bin<br>
调整目标磁盘生成工具</p>
<p>底层与磁盘有关的丢给ide_xx来实现，因为要用到IO中断，要给对应的权限<br>
通过bc_pgfault来实现缺页自己映射，利用flush_block来回写磁盘<br>
然后通过分block利用block cache实现对于磁盘的数据读入内存或者写回磁盘<br>
再上面一层的file_read与file_write，均是对于blk的操作。<br>
再上面就是文件系统服务器，通过调用file_read实现功能了。<br>
客户端通过对需求打包，发送IPC给文件系统服务器，即可实现读／写文件的功能。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Clustering 聚类]]></title>
        <id>https://zjy98.github.io/post/clustering-ju-lei/</id>
        <link href="https://zjy98.github.io/post/clustering-ju-lei/">
        </link>
        <updated>2020-05-08T00:06:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="有监督学习和无监督学习">有监督学习和无监督学习</h1>
<p>给定训练集<br>
学习一个函数f:x-&gt;y</p>
<h1 id="应用">应用</h1>
<p>图像分割Images Segmentation，文档分类<br>
market Segmentation<br>
Social Network Analysis</p>
<h1 id="聚类问题描述">聚类问题描述</h1>
<p>聚类分析：发现不同的数据类簇/群组，使得组内的数据具有较高的相似性或相关性，而组间的数据具有较低的相似性或相关性。<br>
<img src="https://zjy98.github.io/post-images/1588896918272.png" alt="" loading="lazy"><br>
无监督，没有正确的标准<br>
类簇划分可以有多个角度：well-sparated clusters  contiguous cluster(有邻接关系)<br>
density-based(基于密度的) center-based(靠距离中心) shared property or conceptual clusters</p>
<h1 id="聚类方法的划分">聚类方法的划分</h1>
<ul>
<li>
<p>划分聚类 partitional clstering<br>
<img src="https://zjy98.github.io/post-images/1588897606556.png" alt="" loading="lazy"></p>
</li>
<li>
<p>层次聚类 hierarchical clustering<br>
<img src="https://zjy98.github.io/post-images/1588897639361.png" alt="" loading="lazy"></p>
</li>
<li>
<p>Exclusive &amp; non-exclusive 排他和非排他</p>
</li>
<li>
<p>Fuzzy &amp; non-fuzzy 模糊和非模糊<br>
weights must sum to 1</p>
</li>
<li>
<p>Partial &amp; complete<br>
In some cases,we only want to cluster some of the data</p>
</li>
<li>
<p>Heterogeneous &amp; homogeneous 异构<br>
Cluster of widely different sizes,shapes,and densities</p>
<h1 id="常用的聚类算法">常用的聚类算法</h1>
<h2 id="k-means">K-means</h2>
<p>1.先确定簇的个数，k<br>
2.假设每个簇都有一个中心点centroid<br>
3.将每个样本点划分到距离它最近的中心点所属的簇中<br>
select K points as the initial centroids<br>
repeat<br>
From K clusters by assigning all points to the closets centroid<br>
Recompute the centroid of each cluster<br>
Until the centroids don't change<br>
<img src="https://zjy98.github.io/post-images/1588898467845.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588898867084.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588898914327.png" alt="" loading="lazy"><br>
如何选取比较好的初始中心点？<br>
1.凭经验选择代表点<br>
2.全部数据随机分成c类，计算每类重心作为初始点<br>
3.用密度法选择代表点<br>
4.将样本随机排序后使用前c个点作为代表点<br>
5.从c-1聚类划分问题的解中产生c聚类划分问题的代表点<br>
对数据没有特别了解，可直接选择2和4方法</p>
</li>
<li>
<p>如何选取K<br>
SSE一般随着k的增大而减小<br>
Limitations of K-means<br>
<img src="https://zjy98.github.io/post-images/1588899870211.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="hierarchical-clustering">Hierarchical clustering</h2>
<p>为数据集输出一个嵌套的、层次化的类别树：dendrogram<br>
树结构记录了簇的合并或拆分<br>
自底向上 agglomerative<br>
自顶向下 divisive<br>
层次凝聚聚类：一种很常用的聚类模型<br>
<img src="https://zjy98.github.io/post-images/1588900023583.png" alt="" loading="lazy"><br>
关键步骤：计算两个簇的相似度<br>
不同的度量两个簇的相似度方法，区分了不同的聚类算法<br>
初始状态：每个点代表一个簇以及一个相似度矩阵proximity matrix<br>
<img src="https://zjy98.github.io/post-images/1588900656204.png" alt="" loading="lazy"><br>
中间状态：经过几次合并操作，得到一些簇以及一个相似度矩阵<br>
<img src="https://zjy98.github.io/post-images/1588900661590.png" alt="" loading="lazy"><br>
合并操作：合并最近的两个簇（c2 and c5)，同事更新相似度矩阵<br>
<img src="https://zjy98.github.io/post-images/1588900667232.png" alt="" loading="lazy"><br>
如何更新相似度矩阵？<br>
Inter-cluster similarity<br>
两个不相交的簇G和H，其间的相似度D（G,H)可以通过点点间的相似度(pairwise similarities) D(i,j),i∈G，j∈H，计算得到<br>
MIN(single linkage)<br>
MAX(complete linkage)<br>
Group Average<br>
<img src="https://zjy98.github.io/post-images/1588900681725.png" alt="" loading="lazy"><br>
single linkage:优势：单链技术可以处理非椭圆形状的簇。不足：对噪音和离群点很敏感<br>
complete linkage:优势：对噪音和离群不敏感 不足：可能使大的簇破裂，偏好球形簇<br>
Group Average:优势：对噪音和极端值影响小 不足：偏好球形簇</p>
<p>** summary **<br>
优点：对类别个数不做假设<br>
通过在不同层的分析，可以获得任意数目的类别<br>
所获得类别可能对应一个有意义的分类体系taxonomies<br>
缺点：缺少目标函数，对噪声和离群点敏感，计算、存储量大</p>
<h2 id="gaussian-mixture-model">Gaussian Mixture Model</h2>
<p>概率聚类模型<br>
将训练数据的概率分布描述为一个混合模型<br>
建模数据的分布<br>
建模类簇划分时的不确定性<br>
一个常用的混合模型：mixtures of Gaussians<br>
<img src="https://zjy98.github.io/post-images/1588900687922.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588900693511.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588900698295.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588900703815.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588900708906.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数]]></title>
        <id>https://zjy98.github.io/post/han-shu/</id>
        <link href="https://zjy98.github.io/post/han-shu/">
        </link>
        <updated>2020-05-07T16:59:56.000Z</updated>
        <content type="html"><![CDATA[<p>语法：<br>
name() {list;}<br>
函数定义完成之后，该函数名作为一个自定义内部命令执行，后面可以调用，调用时函数名后附加0到多个参数，在函数体内部以$1,$2...或$*,$@方式引用。函数体内用内部命令return使函数，0表示成功，非0表示失败。函数内部可以创建和修改变量</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[表达式运算 循环]]></title>
        <id>https://zjy98.github.io/post/biao-da-shi-yun-suan-xun-huan/</id>
        <link href="https://zjy98.github.io/post/biao-da-shi-yun-suan-xun-huan/">
        </link>
        <updated>2020-05-07T07:25:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="表达式运算">表达式运算</h1>
<p>shell不支持除字符串外的数据类型，不支持加减乘除等算数运算和关于字符串的正则表达式运算<br>
需要这些功能，借助于shell之外的可执行程序<br>
/usr/bin/expr实现<br>
有的shell（包括bash)为了提高执行效率，提供内部命令版本的echo,printf,expr,test,[等命令，但这仅仅是一种性能优化措施。只依赖外部命令完全可以实现</p>
<h2 id="expr命令">expr命令</h2>
<p><img src="https://zjy98.github.io/post-images/1588836535381.png" alt="" loading="lazy"><br>
注意：应该有的空格的地方不允许漏掉<br>
应该转义的地方必须加反斜线转义<br>
<img src="https://zjy98.github.io/post-images/1588836695143.png" alt="" loading="lazy"><br>
正则表达式运算：<br>
用法：expr string : pattern<br>
正则表达式pattern匹配字符串string,打印匹配长度<br>
pattern中用\和)括起一部分，能匹配时打印括号内能匹配的部分，否则为空字符串<br>
<img src="https://zjy98.github.io/post-images/1588850083889.png" alt="" loading="lazy"><br>
-w:限时1秒</p>
<h1 id="while循环">while循环</h1>
<p>while condition<br>
do list<br>
done<br>
例如：等待文件 lockfile 消失：<br>
while test -r lockfile<br>
do<br>
sleep 5<br>
done<br>
正确的写法：<br>
while test -r lockfile; do<br>
sleep 5<br>
done<br>
do要和while要加分号<br>
或者全写1行 while test -r lockfile; do sleep 5;done</p>
<h1 id="内部命令eval">内部命令eval</h1>
<p>将程序中输入的或者加工出来的数据作为程序来执行</p>
<ul>
<li>解释和编译</li>
<li>将数据（程序生成的数据或者外部输入的数据）当做程序来执行是只有解释型语言才可能具备的特点，类似C这样的编译型语言无法具备这样的功能（但可以通过动态链接的方式，在程序运行期间不停止程序的运行有限度地变换处理程序）<br>
<img src="https://zjy98.github.io/post-images/1588853579915.png" alt="" loading="lazy"></li>
</ul>
<h1 id="for循环">for循环</h1>
<p>for name in word1 word2...<br>
do list<br>
done<br>
每次从表格里取一个词执行<br>
for name<br>
do list<br>
done<br>
相当于<br>
for name in $1 $2<br>
do list<br>
done<br>
每次取命令行参数1个<br>
seq命令：<br>
for i in <code>seq 1 254\</code><br>
do<br>
ping -c 1 -w 1 192.168.0$i<br>
done<br>
每次取i，1到254<br>
可以直接写为一整行<br>
<img src="https://zjy98.github.io/post-images/1588870464114.png" alt="" loading="lazy"><br>
先判断目录是否存在，在etc这个目录下照rc.d这个子目录，二级目录执行完再执行一级目录，如果rc.d下还有子目录，再执行</p>
<p>break,continue,exit 和C语言类似</p>
<ul>
<li>break:循环结构for/while中使用，中止循环<br>
例：break break2(可以打破两层循环)</li>
<li>continue 提前结束本轮循环</li>
<li>exit:结束脚本程序的执行，退出。exit的参数为该进程执行结束后的返回码<br>
例：exit 1</li>
</ul>
]]></content>
    </entry>
</feed>