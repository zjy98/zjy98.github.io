<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zjy98.github.io</id>
    <title>Just FOR 1998</title>
    <updated>2021-12-02T06:31:33.889Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zjy98.github.io"/>
    <link rel="self" href="https://zjy98.github.io/atom.xml"/>
    <subtitle>LOVE YOURSELF</subtitle>
    <logo>https://zjy98.github.io/images/avatar.png</logo>
    <icon>https://zjy98.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Just FOR 1998</rights>
    <entry>
        <title type="html"><![CDATA[教学设计]]></title>
        <id>https://zjy98.github.io/post/jiao-xue-she-ji/</id>
        <link href="https://zjy98.github.io/post/jiao-xue-she-ji/">
        </link>
        <updated>2021-02-19T14:56:34.000Z</updated>
        <content type="html"><![CDATA[<p><strong>教学设计万能模板</strong><br>
一、教学目标<br>
1、知识与技能<br>
2、过程与方法<br>
3、情感态度与价值观<br>
二、教学的重点和难点<br>
三、教学方法<br>
四、教学过程<br>
1、导入新课<br>
2、讲授新课<br>
3、巩固练习<br>
4、课堂小结<br>
5、布置作业<br>
五、板书设计<br>
六、教学反思</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[毕业设计]]></title>
        <id>https://zjy98.github.io/post/bi-ye-she-ji/</id>
        <link href="https://zjy98.github.io/post/bi-ye-she-ji/">
        </link>
        <updated>2021-02-16T15:40:40.000Z</updated>
        <content type="html"><![CDATA[<p>一、E-R图<br>
学生（学号 姓名 课程ID 课程成绩 排名 考勤）<br>
课程（课程ID 课程名 学分 上课地点）<br>
老师（姓名 教师ID 课程ID）<br>
二、Flask<br>
Flask构造函数使用当前模块（<strong>name</strong>)的名称作为参数<br>
Flask类的route()函数是一个装饰器，告诉应用程序哪个URL应该调用相关的函数<br>
app.route(rule,options)</p>
<ul>
<li>rule参数表示与该函数的URL绑定</li>
<li>options是要转发给基础Rule对象的参数列表。</li>
</ul>
<p>app.run(host,port,debug,options)</p>
<p>'/'URL与hello_world()函数绑定<br>
Flask中的route()装饰器用于将URL绑定到函数。<br>
@app.route('/hello')<br>
def hello_world():<br>
return 'hello world'</p>
<p>在这里，URL'/hello'规则绑定到hello_world()函数。因此，如果用户访问http://localhost:5000/hello URL,hello_world()函数的输出将在浏览器中呈现。</p>
<p>返回模板：用render_template（index.html）<br>
重定向：redirect</p>
<p>app.route('/login',methods=['GET','POST'],endpoint = 11)<br>
第一个参数是路径<br>
methods 请求方式<br>
endpoint 别名，如果不写，用函数名作别名</p>
<p>路由的本质：self.add_url_rule</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[考研复习]]></title>
        <id>https://zjy98.github.io/post/kao-yan-fu-xi/</id>
        <link href="https://zjy98.github.io/post/kao-yan-fu-xi/">
        </link>
        <updated>2020-07-26T15:51:13.000Z</updated>
        <content type="html"><![CDATA[<p>8:00-8:40 复习碎片化知识：英语单词、政治背诵、作文背诵<br>
8:50-11:50 复习教育综合333<br>
13::30-14:00: 复习碎片化知识<br>
14:00-17:00 复习专业课<br>
17:10-18:00 复习碎片化知识<br>
20:00-22:00 复习专业课<br>
22:30-23:30 归纳总结</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[产品面试宝典]]></title>
        <id>https://zjy98.github.io/post/chan-pin-mian-shi-bao-dian/</id>
        <link href="https://zjy98.github.io/post/chan-pin-mian-shi-bao-dian/">
        </link>
        <updated>2020-07-23T03:49:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="专业名词">专业名词</h1>
<p><strong>TO C类</strong>：面向消费者的产品<br>
<strong>TO B类</strong>：面向企业的产品<br>
2类产品在品牌营销上方式的区别：<br>
1.线下：</p>
<ul>
<li>TO C类的市场推广目的是<strong>拉新</strong>，提升GMV（成交总额）等，推广手段大多是扫楼、展台、易拉宝、传单、条幅、灯箱、刷墙广告等。</li>
<li>TO B类目的是提升品牌的知名度和美誉度，一般通过自己或联合举办，参加座谈会，分享会，论坛，奖项评比等方式。<br>
2.线上：</li>
<li>TO C类产品的内容营销目的是增加用户粘性，通过策划、生产、发布与用户相关的内容，刺激用户购买，使用产品和服务，在内容选题上，因为大部分普通用户是年轻群体，需求是生活中的某个具体需求，所以内容题材较为广泛，风格多样化。</li>
<li>TO B类产品的内容营销目的是增强品牌知名度和美誉度，通过撰写企业服务案例、市场活动报道、产品新功能等内容，让目标用户对产品产生好感，进而试用体验。而且由于用户一般是企业CEO或高管，所以题材更注重专业性，较为狭窄。<br>
3.PR宣传方式维度</li>
<li>TO C类产品的PR稿件更多的涉及到平台活动，联合活动，融资信息，供应商等方面，目的是增强品牌在用户群体中的知名度，进而提升GMV</li>
<li>TO B类产品的PR宣传更多涉及到企业用户的服务案例、企业市场活动报道（论坛、峰会、分享会等）融资信息、产品更新等，让用户感知到产品的专业性，提升用户信任感。</li>
</ul>
<p><strong>微博曾经一度衰落又再次兴起的原因 未来微博该如何发展</strong><br>
1.过度的明星运营<br>
在微博发展早期，通过明星效应拉动用户的运营手法确实有效，建立起的资源优势让其他竞品无法追赶，但到产品中后期，微博已经普遍但缺乏转变思路，还是大量的大V掌控话语权和影响力，没有回归普通用户，用户在微博逐渐失去存在感和兴趣。大量的营销公司微博刷粉刷转发对普通用户发表和获取信息也造成伤害。<br>
2.没有根据用户需求的变化而迭代<br>
微博一开始最基本的需求是获取资讯，但很多重复的心灵鸡汤出现，当出现体验更优秀的深度阅读产品时，微博这种快消式的资讯产品就显得不足。其次，发微博这个功能点并不需要满足用户需要潜在观众的需求，而微信朋友圈更精准。<br>
3.产品定位不明确<br>
社交平台还是媒体平台，产品初心不明确。</p>
<p>再次兴起的原因：<br>
微信朋友圈产生蒸发式降温的社交效应后（即一个社交圈的群组人数越多、时间越长，就会出现蒸发式降温），许多人选择屏蔽朋友圈，回归另一个树洞（尤其是微博）。<br>
用户的社交需求是动态性的，随着用户的年龄增长或者常住地迁移，用户的朋友圈会不断迭代和扩大，用户会基于不同圈内好友的身份构建一套特定的范畴、经验和特定的社交语境。回顾微信朋友圈的使用经验，最开始什么都愿意分享，到后来微信好友里加入越来越多的家人、同事‘有工作需要对接的人等等，用户的朋友圈变得单调乏味，只表现最基础的自己，或者发工作需要的广告。反而微博的语境更符合用户的需求，更多用户更愿意将有趣的图片分享到微博，不用去刻意维护人设。</p>
<p>未来微博的发展方向：<br>
1.巩固公共社交的广场属性<br>
不同于微信朋友圈的会议室模式，微博是热点事件讨论传播平台，加上独特的“热点源IP”即明星名人资源，自然就称为热点事件的发酵讨论传播平台。用户让微博“多备服务器&quot;的说法就是微博在热点事件中独特价值的佐证。源源不断的热点代表流量，活跃和时长。所以微博应该强化热点事件的相关功能和运营<br>
2.深度运营社交资产<br>
粉丝就是社交资产，常坐着诞生，走红于不同的平台，但他们一般会将微博作为沉淀粉丝的平台，以推动原有平台和全行业的影响力进一步提升。而公众号创作成本和门槛较高，仅是部分优秀创作者的选项。算法类平台（例如今日头条）的粉丝属性不同，微博分发主要基于粉丝，粉丝量与影响力正相关，因此微博的粉丝更具价值，需要深度细化运营。</p>
<p><strong>物联网</strong><br>
就是把实物联入网络，最终实现物品与物品，人与物品之间的全面的信息交互<br>
物与物的连接指向智能化和自动化，计算机采集数据进行计算，并控制各种物品自动解决问题，解放劳动力。人与物的连接拓宽人们接触和使用信息的渠道，人可以做到信息共享、远程感知与操控等。<br>
通过RFID、条码、二维码等信息传感设备，将物品信息采集入计算机，实现智能化识别与管理，是现在也是未来物联网的重要实现方式。无论是给房子贴个二维码，扫一下就能知道其布局、历史、人文内涵，还是干脆对其进行3D建模，在地图上表现出来，都是将其信息传到网上的方式，也是将其联入物联网的方式。</p>
<p><strong>互联网领域，云计算、大数据、人工智能是发展的未来</strong><br>
1.互联网通过计算机可以大规模地收集、存储人类的行为，即应用大数据。所以，当计算机大量积累人类在网络上的行为，我们有可能再通过算法，处理这些积累下来的行为数据，即应用云计算。<br>
2.即把人类的大脑当用作CPU的逻辑门来看，只要你有能力把足够多的大脑连结起来，就有可能让你的系统产生群体智慧。群体智慧中的个体并不了解自己成了一个逻辑门，他们只是为了自己的某个目标行事。但最终，他们的行为被汇总成一个帮助别人决策的结论。 通过这样的方式去解决生活中的问题，越来越多的服务是基于结构化的信息+结构化的人类行为。</p>
<p><strong>广告展示，广告点击，广告转化率</strong><br>
广告展示：该广告在设定时间范围内的展示数量，也可以理解为曝光，广告在页面上曝光显示的次数，显示一次记录为一个pv，被一个用户看到记录为一个uv<br>
广告点击：该广告在设定时间范围内的点击数量，广告被点击一次即为一个pv，被一个用户点击一次即为一个uv<br>
广告转化率=广告点击/广告展示 * 100%，具体是pv还是uv做除法，看实际应用时的衡量维度。</p>
<p><strong>ASO,UGC,PGC,SAAS,NFC</strong><br>
ASO:App Store Optimization 应用商店优化。利用app store的搜索规则和排名规则，提升app的排名和被搜索到的概率，可类比SEO-普通网站针对搜索引擎的优化<br>
UGC:User Generated Content 用户原创内容，用户将自己的原创内容在互联网平台向其他用户进行展示，例如微博、小红书、B站等<br>
PGC（Professional Generated Content），指专业生产内容。经由传统广电业者按照几乎与电视节目无异的方式进行制作，但在内容的传播层面，却必须按照互联网的传播特性进行调整<br>
SAAS:Sofrware-as-a-Service 软件即服务。厂商将应用软件统一部署在自己的服务器上，客户可以根据自己的实际需求，通过互联网向厂商订购自己所需的应用软件服务，按订购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务，类似于集成软件和服务的外包，一些中小型企业可通过购买SAAS系统节约硬件软件服务和相关开发维护人员的高额成本，并可像积木一样在系统上购买搭建延伸服务。一般属于TO B的业务<br>
NFC:Near field communication 近场通讯。非接触的在彼此靠近的情况下可进行数据交换的技术，例如apple pay 手机地铁过闸，门禁，手机识别卡片，等</p>
<p><strong>feed流</strong><br>
feed是将用户主动订阅的若干消息源组合在一起形成内容聚合器，帮助用户持续地获得最新的订阅源内容<br>
严格从定义上来说通常说的搜索结果，排序列表都不能算作feed流<br>
feed流的展现形式有很多种，主要的有timeline和rank，订阅源不再是某个内容，而是生产内容的人/团体。订阅中通常夹杂非订阅内容，比如热门推荐，广告<br>
内容也不再严格按照timeline，广泛使用智能feed排序，新的feed流刻意不再需要主动搜搜，而是主动呈现琳琅满目的内容，它对我们了如指掌，让我们不停刷新。微博、知乎、今日头条、微信朋友圈都是feed流的展示模式。</p>
<p><strong>目前互联网盈利的模式</strong><br>
1.内置商城：销售虚拟道具等，与传统的游戏盈利模式类似。<br>
2.App Store付费下载：刷榜竞争严重，一般配合限时免费做推广，由于国内用户付费习惯差，做国外用户优势大很多<br>
3.增值业务：与一些SP渠道合作，扣手机费分成<br>
4.移动广告：以Banner为主，插屏、全屏、视频和富媒体等形式也有，开发者易受到各移动广告平台的剪刀差价和运营影响，包括扣量，数据核实不标准，Epcm低等。<br>
5.应用墙和积分墙：无积分和有积分模式，CPA计费。<br>
另有交叉补贴，三方市场，开源捐赠，上市收购等“免费”盈利模式。</p>
<p><strong>优酷、腾讯视频、爱奇艺的对比</strong><br>
1.优酷<br>
界面主色调是蓝色。slogan是“这世界很酷”，推崇的是一种文娱酷体验。本着“世界都在看”的目标以及“快者为王”的产品理念，打造快速播放、快速发布、快速搜索的视频数据库，致力于让用户“看得爽、找得快、传得广、比得酷”。欢迎一切以微视频形式出现的视频收藏、自创与分享，建立优酷原创拍客联盟。始终围绕视频核心，没有过多的增值业务。<br>
2.腾讯视频<br>
界面主色调是橙色。slogan是“不负好时光”，强调是一种场景体验。秉承“内容为王，用户为本”的价值观，以更加年轻化、更能引起用户情感共鸣的定位亮相，着力凸显优质内容的差异化竞争优势，深化与消费者的情感沟通。作为HBO中国独家官方播放平台，腾讯视频拥有丰富的美剧阵容。<br>
3.爱奇艺<br>
界面主色调是绿色。slogan是“悦享品质”，体现的是一种高度追求细节品质的经营理念。通过“爱奇艺出品”战略的持续推动，逐步降低版权投入，重点发力自制内容，推出了很多网上大火的自制剧和自制综艺；“品质、青春、时尚”的品牌调性深入人心，网罗了广大的年轻用户群体。从功能架构和设计上来看，爱奇艺已经由一个视频平台转型到泛娱乐开放平台，发展了“乐活”、“泡泡圈”等增值业务，“乐活”中包括了文学、电影票、商城、奇秀直播等，“泡泡圈”围绕明星、IP、综艺节目主打社交功能，引入了更多的用户流量，带动收入增长。</p>
<p>总的来说，如果一个视频网站能做到包揽一切内容资源，那自然所向披靡。但在做不到的情况下，就必须延续差异化政策，继续深化平台定位。例如：不断争取独家版权，放映独家影视内容；整合资源，强化自身优势，让用户对平台有标签化的印象；自己打造精品偶像剧、综艺、直播节目等，生产优质内容等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[产品知识]]></title>
        <id>https://zjy98.github.io/post/chan-pin-zhi-shi/</id>
        <link href="https://zjy98.github.io/post/chan-pin-zhi-shi/">
        </link>
        <updated>2020-07-23T03:49:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="专业名词">专业名词</h1>
<p><strong>TO C类</strong>：面向消费者的产品<br>
<strong>TO B类</strong>：面向企业的产品<br>
2类产品在品牌营销上方式的区别：<br>
1.线下：</p>
<ul>
<li>TO C类的市场推广目的是<strong>拉新</strong>，提升GMV（成交总额）等，推广手段大多是扫楼、展台、易拉宝、传单、条幅、灯箱、刷墙广告等。</li>
<li>TO B类目的是提升品牌的知名度和美誉度，一般通过自己或联合举办，参加座谈会，分享会，论坛，奖项评比等方式。<br>
2.线上：</li>
<li>TO C类产品的内容营销目的是增加用户粘性，通过策划、生产、发布与用户相关的内容，刺激用户购买，使用产品和服务，在内容选题上，因为大部分普通用户是年轻群体，需求是生活中的某个具体需求，所以内容题材较为广泛，风格多样化。</li>
<li>TO B类产品的内容营销目的是增强品牌知名度和美誉度，通过撰写企业服务案例、市场活动报道、产品新功能等内容，让目标用户对产品产生好感，进而试用体验。而且由于用户一般是企业CEO或高管，所以题材更注重专业性，较为狭窄。<br>
3.PR宣传方式维度</li>
<li>TO C类产品的PR稿件更多的涉及到平台活动，联合活动，融资信息，供应商等方面，目的是增强品牌在用户群体中的知名度，进而提升GMV</li>
<li>TO B类产品的PR宣传更多涉及到企业用户的服务案例、企业市场活动报道（论坛、峰会、分享会等）融资信息、产品更新等，让用户感知到产品的专业性，提升用户信任感。</li>
</ul>
<p><strong>微博曾经一度衰落又再次兴起的原因 未来微博该如何发展</strong><br>
1.过度的明星运营<br>
在微博发展早期，通过明星效应拉动用户的运营手法确实有效，建立起的资源优势让其他竞品无法追赶，但到产品中后期，微博已经普遍但缺乏转变思路，还是大量的大V掌控话语权和影响力，没有回归普通用户，用户在微博逐渐失去存在感和兴趣。大量的营销公司微博刷粉刷转发对普通用户发表和获取信息也造成伤害。<br>
2.没有根据用户需求的变化而迭代<br>
微博一开始最基本的需求是获取资讯，但很多重复的心灵鸡汤出现，当出现体验更优秀的深度阅读产品时，微博这种快消式的资讯产品就显得不足。其次，发微博这个功能点并不需要满足用户需要潜在观众的需求，而微信朋友圈更精准。<br>
3.产品定位不明确<br>
社交平台还是媒体平台，产品初心不明确。</p>
<p>再次兴起的原因：<br>
微信朋友圈产生蒸发式降温的社交效应后（即一个社交圈的群组人数越多、时间越长，就会出现蒸发式降温），许多人选择屏蔽朋友圈，回归另一个树洞（尤其是微博）。<br>
用户的社交需求是动态性的，随着用户的年龄增长或者常住地迁移，用户的朋友圈会不断迭代和扩大，用户会基于不同圈内好友的身份构建一套特定的范畴、经验和特定的社交语境。回顾微信朋友圈的使用经验，最开始什么都愿意分享，到后来微信好友里加入越来越多的家人、同事‘有工作需要对接的人等等，用户的朋友圈变得单调乏味，只表现最基础的自己，或者发工作需要的广告。反而微博的语境更符合用户的需求，更多用户更愿意将有趣的图片分享到微博，不用去刻意维护人设。</p>
<p>未来微博的发展方向：<br>
1.巩固公共社交的广场属性<br>
不同于微信朋友圈的会议室模式，微博是热点事件讨论传播平台，加上独特的“热点源IP”即明星名人资源，自然就称为热点事件的发酵讨论传播平台。用户让微博“多备服务器&quot;的说法就是微博在热点事件中独特价值的佐证。源源不断的热点代表流量，活跃和时长。所以微博应该强化热点事件的相关功能和运营<br>
2.深度运营社交资产<br>
粉丝就是社交资产，常坐着诞生，走红于不同的平台，但他们一般会将微博作为沉淀粉丝的平台，以推动原有平台和全行业的影响力进一步提升。而公众号创作成本和门槛较高，仅是部分优秀创作者的选项。算法类平台（例如今日头条）的粉丝属性不同，微博分发主要基于粉丝，粉丝量与影响力正相关，因此微博的粉丝更具价值，需要深度细化运营。</p>
<p><strong>物联网</strong><br>
就是把实物联入网络，最终实现物品与物品，人与物品之间的全面的信息交互<br>
物与物的连接指向智能化和自动化，计算机采集数据进行计算，并控制各种物品自动解决问题，解放劳动力。人与物的连接拓宽人们接触和使用信息的渠道，人可以做到信息共享、远程感知与操控等。<br>
通过RFID、条码、二维码等信息传感设备，将物品信息采集入计算机，实现智能化识别与管理，是现在也是未来物联网的重要实现方式。无论是给房子贴个二维码，扫一下就能知道其布局、历史、人文内涵，还是干脆对其进行3D建模，在地图上表现出来，都是将其信息传到网上的方式，也是将其联入物联网的方式。</p>
<p><strong>互联网领域，云计算、大数据、人工智能是发展的未来</strong><br>
1.互联网通过计算机可以大规模地收集、存储人类的行为，即应用大数据。所以，当计算机大量积累人类在网络上的行为，我们有可能再通过算法，处理这些积累下来的行为数据，即应用云计算。<br>
2.即把人类的大脑当用作CPU的逻辑门来看，只要你有能力把足够多的大脑连结起来，就有可能让你的系统产生群体智慧。群体智慧中的个体并不了解自己成了一个逻辑门，他们只是为了自己的某个目标行事。但最终，他们的行为被汇总成一个帮助别人决策的结论。 通过这样的方式去解决生活中的问题，越来越多的服务是基于结构化的信息+结构化的人类行为。</p>
<p><strong>广告展示，广告点击，广告转化率</strong><br>
广告展示：该广告在设定时间范围内的展示数量，也可以理解为曝光，广告在页面上曝光显示的次数，显示一次记录为一个pv，被一个用户看到记录为一个uv<br>
广告点击：该广告在设定时间范围内的点击数量，广告被点击一次即为一个pv，被一个用户点击一次即为一个uv<br>
广告转化率=广告点击/广告展示 * 100%，具体是pv还是uv做除法，看实际应用时的衡量维度。</p>
<p><strong>ASO,UGC,PGC,SAAS,NFC</strong><br>
ASO:App Store Optimization 应用商店优化。利用app store的搜索规则和排名规则，提升app的排名和被搜索到的概率，可类比SEO-普通网站针对搜索引擎的优化<br>
UGC:User Generated Content 用户原创内容，用户将自己的原创内容在互联网平台向其他用户进行展示，例如微博、小红书、B站等<br>
PGC（Professional Generated Content），指专业生产内容。经由传统广电业者按照几乎与电视节目无异的方式进行制作，但在内容的传播层面，却必须按照互联网的传播特性进行调整<br>
SAAS:Sofrware-as-a-Service 软件即服务。厂商将应用软件统一部署在自己的服务器上，客户可以根据自己的实际需求，通过互联网向厂商订购自己所需的应用软件服务，按订购的服务多少和时间长短向厂商支付费用，并通过互联网获得厂商提供的服务，类似于集成软件和服务的外包，一些中小型企业可通过购买SAAS系统节约硬件软件服务和相关开发维护人员的高额成本，并可像积木一样在系统上购买搭建延伸服务。一般属于TO B的业务<br>
NFC:Near field communication 近场通讯。非接触的在彼此靠近的情况下可进行数据交换的技术，例如apple pay 手机地铁过闸，门禁，手机识别卡片，等</p>
<p><strong>feed流</strong><br>
feed是将用户主动订阅的若干消息源组合在一起形成内容聚合器，帮助用户持续地获得最新的订阅源内容<br>
严格从定义上来说通常说的搜索结果，排序列表都不能算作feed流<br>
feed流的展现形式有很多种，主要的有timeline和rank，订阅源不再是某个内容，而是生产内容的人/团体。订阅中通常夹杂非订阅内容，比如热门推荐，广告<br>
内容也不再严格按照timeline，广泛使用智能feed排序，新的feed流刻意不再需要主动搜搜，而是主动呈现琳琅满目的内容，它对我们了如指掌，让我们不停刷新。微博、知乎、今日头条、微信朋友圈都是feed流的展示模式。</p>
<p><strong>BRD</strong><br>
Bussiness Requirement Document商业需求文档，回答的是产品价值是什么？也就是这个产品解决了什么问题。<br>
受众是：老板、投资人、股东，目的是让他们知道这个产品如何给公司盈利，侧重需求描述，盈利模式。</p>
<p><strong>MRD</strong><br>
Market Requirement Document市场需求文旦<br>
<strong>目前互联网盈利的模式</strong><br>
1.内置商城：销售虚拟道具等，与传统的游戏盈利模式类似。<br>
2.App Store付费下载：刷榜竞争严重，一般配合限时免费做推广，由于国内用户付费习惯差，做国外用户优势大很多<br>
3.增值业务：与一些SP渠道合作，扣手机费分成<br>
4.移动广告：以Banner为主，插屏、全屏、视频和富媒体等形式也有，开发者易受到各移动广告平台的剪刀差价和运营影响，包括扣量，数据核实不标准，Epcm低等。<br>
5.应用墙和积分墙：无积分和有积分模式，CPA计费。<br>
另有交叉补贴，三方市场，开源捐赠，上市收购等“免费”盈利模式。</p>
<p><strong>优酷、腾讯视频、爱奇艺的对比</strong><br>
1.优酷<br>
界面主色调是蓝色。slogan是“这世界很酷”，推崇的是一种文娱酷体验。本着“世界都在看”的目标以及“快者为王”的产品理念，打造快速播放、快速发布、快速搜索的视频数据库，致力于让用户“看得爽、找得快、传得广、比得酷”。欢迎一切以微视频形式出现的视频收藏、自创与分享，建立优酷原创拍客联盟。始终围绕视频核心，没有过多的增值业务。<br>
2.腾讯视频<br>
界面主色调是橙色。slogan是“不负好时光”，强调是一种场景体验。秉承“内容为王，用户为本”的价值观，以更加年轻化、更能引起用户情感共鸣的定位亮相，着力凸显优质内容的差异化竞争优势，深化与消费者的情感沟通。作为HBO中国独家官方播放平台，腾讯视频拥有丰富的美剧阵容。<br>
3.爱奇艺<br>
界面主色调是绿色。slogan是“悦享品质”，体现的是一种高度追求细节品质的经营理念。通过“爱奇艺出品”战略的持续推动，逐步降低版权投入，重点发力自制内容，推出了很多网上大火的自制剧和自制综艺；“品质、青春、时尚”的品牌调性深入人心，网罗了广大的年轻用户群体。从功能架构和设计上来看，爱奇艺已经由一个视频平台转型到泛娱乐开放平台，发展了“乐活”、“泡泡圈”等增值业务，“乐活”中包括了文学、电影票、商城、奇秀直播等，“泡泡圈”围绕明星、IP、综艺节目主打社交功能，引入了更多的用户流量，带动收入增长。</p>
<p>总的来说，如果一个视频网站能做到包揽一切内容资源，那自然所向披靡。但在做不到的情况下，就必须延续差异化政策，继续深化平台定位。例如：不断争取独家版权，放映独家影视内容；整合资源，强化自身优势，让用户对平台有标签化的印象；自己打造精品偶像剧、综艺、直播节目等，生产优质内容等。</p>
<h1 id="面试典型问题">面试典型问题</h1>
<p>1.产品经理最应该具备什么样的能力<br>
答：执行能力、沟通能力、自学能力、逻辑思维能力、创新力<br>
2.产品经理需要做什么工作<br>
答：产品规划（包括用户调研、数据分析等需求分析手段）<br>
产品设计（竞品分析、产品脑图、产品流程图、产品原型图、产品说明文档）<br>
产品落地（需求评审、需求排期、项目跟进、上线走查等项目管理）</p>
<h1 id="需求金字塔">需求金字塔</h1>
<p>狩野纪昭(Noriaki Kano)将影响满意度的因素划分为五个类型：（1）基本型需求；（2）期望型需求；（3）魅力型需求；（4）无差异型需求；（5）反向型需求。<br>
（1）基本型需求：就是用户不说却必须存在的理所当然的需求，即痛点。当需求满足时，用户不会感到满意，但当不被满足时，用户会很不满意。就好比一个手机却通话质量不好，直接就可以go die了。<br>
（2）期望型需求：与用户满意度成正相关的需求，也叫用户需求的痒处。当需求满足时，用户会很满意，当不被满足时，用户会很不满意。就好比手机的拍照功能。<br>
（3）魅力型需求：也称为兴奋型需求，是企业给用户提供的惊喜型需求。该需求大大超出了用户对产品本来的期望，使得用户的满意度急剧上升，所以即使表现的不太完善，用户的满意程度也非常高。而即使该期望没有被满足，用户也不会感到不满意。这就好像iPhone X的面部识别，即使识别速度有时慢或者不准，也有一大批用户蜂拥购买。<br>
（4）无差异型需求：就是说该需求被满足或未被满足，都不会对用户的满意度造成影响。<br>
（5）反向型需求：该需求刚好与用户的满意度呈反向相关，满足该要求，反而会使用户的满意度下降。</p>
<h1 id="做竞品分析的常用方法">做竞品分析的常用方法：</h1>
<p>体验法：深度体验，截图保存<br>
对比法：功能对比法，编制表格<br>
回溯法：关注功能上线时间和消失时间<br>
SWTO：优劣势分析<br>
MECE：互相独立，完全穷尽<br>
空雨伞：麦肯锡分析方法，现状、意义、解决方案</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[测试题]]></title>
        <id>https://zjy98.github.io/post/ce-shi-ti/</id>
        <link href="https://zjy98.github.io/post/ce-shi-ti/">
        </link>
        <updated>2020-06-16T12:11:46.000Z</updated>
        <content type="html"><![CDATA[<p>1.在同一台Linux上的两个进程之间交换数据可以通过下列两种方式。一，使用TCP Socket完成；二，两进程共享内存，并使用信号量(semaphore)的P/V操作操作完成。两种方式各有那些利弊？<br>
2.使用Linux与进程管理有关的系统调用，编写 C语言程序，使用与下列shell命令相同的机制完成同样的功能。</p>
<p>ps -ef &gt; proc.list; grep root &lt; proc.list</p>
<p>为简化编程，假设系统调用执行均能成功，不考虑失败的情况。</p>
<p>提示：相关的系统调用如下：</p>
<p>创建新进程用fork()<br>
exec系统调用可以用execlp(file，argv0, argv1, …, 0);<br>
创建匿名管道pipe(int fd[2]); 其中fd[0]为读端，fd[1]为写端<br>
dup2系统调用用法为 dup2(srcfd, dstfd); srcfd覆盖掉dstfd<br>
打开文件读 fd = open(filename, O_RDONLY);<br>
打开文件写 fd=open(filename, O_CREAT | O_WRONLY, 0666);</p>
<pre><code class="language-c">    int fd, sv;
    if (fork() == 0) {
        fd = open(&quot;proc.list&quot;, O_CREAT | O_WRONLY, 0666);
        dup2(fd, 1);
        close(fd);
        execlp(&quot;ps&quot;, &quot;ps&quot;, &quot;-ef&quot;, 0);
    } else {
        wait(&amp;sv);
        fd = open(&quot;proc.list&quot;, O_RDONLY);
        dup2(fd, 0);
        close(fd);
        execlp(&quot;grep&quot;, &quot;grep&quot;, &quot;root&quot;, 0);
    }
}
</code></pre>
<p>3.字符终端上执行cat /usr/bin/bash之后屏幕开始显示乱码，按下Ctrl-C中止后，无论从键盘输入什么内容，屏幕回显的内容都是各种线条等制表符号。解释产生这一现象的原因。<br>
4.在Windows下输入命令名，系统首先检索当前目录下是否有这个可执行文件，检索不到，会逐个检查PATH环境变量列出的各目录。Linux不自动检索当前目录，而且环境变量PATH中一般不含当前目录./，为什么？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Socket概述]]></title>
        <id>https://zjy98.github.io/post/socket-gai-shu/</id>
        <link href="https://zjy98.github.io/post/socket-gai-shu/">
        </link>
        <updated>2020-06-14T18:07:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="socket">Socket</h1>
<ul>
<li>协议栈实现<br>
传输层以上由用户态应用程序实现<br>
传输层和网络互联层协议在内核中实现（路由协议由用户态进程实现）<br>
第一第二层一般由硬件实现</li>
<li>UNIX提供给应用程序使用网络功能的方法<br>
BSD将设备和通信管道组织成文件方式，创建方式不同，访问方法相同<br>
终端设备、管道、通信服务Socket</li>
<li>Socket编程接口面向网络通信，不仅仅用于TCP/IP<br>
利用虚拟loopback接口（127.0.0.1）可实现同台计算机进程间通信</li>
</ul>
<h1 id="tcp与udp">TCP与UDP</h1>
<p>TCP：<br>
面向连接，可靠（保证收到的数据是对的，不是保证一定能收到——，字节流传输，不保证报文边界<br>
UDP:<br>
面向数据报，不可靠（丢报，乱序，流量控制，数据报传输），广播和组播</p>
<h1 id="客户端程序">客户端程序</h1>
<ul>
<li>创建文件描述符socket</li>
<li>建立连接socket<br>
进程阻塞，等待TCP连接建立</li>
<li>端点名的概念：IP地址+端口号<br>
本地端点名 远端端点名</li>
<li>发送数据<br>
发送速率大于通信速率，进程会被阻塞</li>
<li>关闭连接</li>
</ul>
<h1 id="服务端程序">服务端程序</h1>
<p>bind(admin_sock,(struct sockaddr*)&amp;name,sizeof(name));指定了端口号<br>
listen(admin_sock,5);监听等待 参数用处不大<br>
accept(admin_sock,0,0)真正建立连接（三次握手）<br>
建立一个socket（新获得的）</p>
<h1 id="socket系统调用">socket系统调用</h1>
<ul>
<li>socket<br>
创建文件描述符socket,端点名未指定</li>
<li>bind<br>
设定本地端点名，也可以用在用户端程序</li>
<li>listen<br>
开始监听到达的连接请求</li>
<li>accept<br>
接受一个连接请求，TCP三次握手结束accept返回，返回值是另一个socket</li>
<li>connect<br>
建立连接，设定远端端点名，TCP连接建立，函数返回</li>
<li>close<br>
关闭连接，释放文件描述符<br>
创建新进程是的文件描述符处理：<br>
问题：不能同时接纳多个连接<br>
多进程并发处理，单进程并发处理</li>
</ul>
<h1 id="多进程并发处理">多进程并发处理</h1>
<p>服务器端肯定不能用一个socket<br>
<img src="https://zjy98.github.io/post-images/1592279710910.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1592279731796.png" alt="" loading="lazy"><br>
父进程：负责close(data_sock)<br>
（必须执行：1.每个进程能打开的文件数目有限。2.子进程TCP已经关闭了，父进程还没关，无法中断连接）<br>
子进程：负责读取<br>
<img src="https://zjy98.github.io/post-images/1592280031537.png" alt="" loading="lazy"></p>
<h2 id="readwrite系统调用">read/write系统调用</h2>
<p>与TCP通信的时序<br>
主机A用write()通过TCP连接向B发送数据，B接受数据用read()<br>
<img src="https://zjy98.github.io/post-images/1592280622178.png" alt="" loading="lazy"><br>
read()在什么时候解除阻塞<br>
write()在t1就返回了（系统调用成功，即把数据放在发送缓冲区了，不一定发送成功了）<br>
read()在 t3返回 接收到DATA就返回，在发ACK之前</p>
<ul>
<li>read/write与TCP通信故障和流控<br>
流控问题<br>
断线<br>
对方重启动<br>
keepalive(默认2小时)<br>
getsockopt/setsoclopt可以设置保活间隔，重传次数，重传时间</li>
<li>粘连问题</li>
<li>read/write与UDP通信<br>
网络故障<br>
没有数据粘连<br>
没有流控功能<br>
不可靠<br>
<img src="https://zjy98.github.io/post-images/1592281005864.png" alt="" loading="lazy"></li>
</ul>
<h2 id="shutdown系统调用">shutdown系统调用</h2>
<p>int shutdown(int sockfd,int howto)<br>
禁止发送活接收，socket提供全双工通信，两个方向上都可以收发数据，shutdown提供了对于一个方向的通信控制。<br>
参数howto取值：<br>
SHUT_RD：不能再接收数据，随后read均返回0<br>
SHUT_WR：不能再发送数据，本方向再次write会导致SIGPIP信号<br>
SHUT_RDWR：禁止这个sockfd上的任何收发<br>
shutdown是通用的套接字上的操作<br>
TCP协议：<br>
1.允许关闭发送方向的半个连接<br>
2.没有一种机制让对方关闭它的发送，但TCP协议的流量控制机制，可以通知对方自己的接收窗口W为0，对方的write会继续，并将数据堆积在发送缓冲区<br>
UDP协议：<br>
UDP关闭接收方向内核仅记下一个标记，不再提供数据，但无法阻止对方的发送而导致的网络上数据<br>
即使套接字关闭也不影响对方发出无人接收的数据报</p>
<h2 id="socket控制">socket控制</h2>
<p>getsockopt、setsockopt、ioctl<br>
无阻塞I/O<br>
执行read/write立即返回，不会导致进程阻塞<br>
<img src="https://zjy98.github.io/post-images/1592281451503.png" alt="" loading="lazy"></p>
<h1 id="单进程并发处理">单进程并发处理</h1>
<h1 id="select多路io">select:多路I/O</h1>
<p>引入select系统调用的原因：<br>
使得用户进程可同时等待多个事件发生<br>
用户进程告知内核多个事件，某一个或多个事件发生时select返回<br>
用户进程告知内核多个事件，某一个或多个事件发生是select返回，否则进程睡眠等待<br>
<img src="https://zjy98.github.io/post-images/1592287141170.png" alt="" loading="lazy"><br>
什么叫准备好：<br>
rfds中某文件描述符的read不会阻塞<br>
wdfs中某文件描述符的write不会阻塞<br>
efds中某文件描述符发生了异常情况<br>
TCP协议，只有加急数据到达才算异常情况<br>
对方连接关闭或网络故障，不算异常情况</p>
<p>准备好后可以进行的操作<br>
当读准备好时，调用read会立刻返回-1<br>
当写准备好时，调用write可以写多少字节？</p>
<blockquote>
<p>=1个字节，无阻塞I/O方式</p>
</blockquote>
<p>集合操作：<br>
<img src="https://zjy98.github.io/post-images/1592287419141.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1592287435926.png" alt="" loading="lazy"></p>
<p><img src="https://zjy98.github.io/post-images/1592287518969.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1592287560770.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1592288038330.png" alt="" loading="lazy"><br>
比多进程效率要高<br>
select：面向事件的编程模式</p>
<h1 id="udp通信">UDP通信</h1>
<p><img src="https://zjy98.github.io/post-images/1592292583357.png" alt="" loading="lazy"><br>
connect：<br>
不产生网络流量，内核记下远端端点名<br>
之前未用bind指定本地端点名，系统自动分配本地端点名<br>
write:<br>
使用前面connect调用指定的端点名<br>
UDP不是面向连接的协议，可在sendto参数中指定对方端点名，而且允许对方端点名不同<br>
每次都使用sendto发送数据，前面的connect调用没必要<br>
connect/第一次sendto可使得socket获得系统动态分配的本地端点名，未获得本地端点名之前不该执行read或recv以及recvfrom<br>
<img src="https://zjy98.github.io/post-images/1592292804526.png" alt="" loading="lazy"><br>
没办法支持多个并发数据，改造如下<br>
<img src="https://zjy98.github.io/post-images/1592292841552.png" alt="" loading="lazy"></p>
<ul>
<li>接收<br>
没有数据到达时，read调用会使得进程睡眠等待，<br>
一般需要区分数据来自何处，常用recvfrom获得对方的端点名</li>
<li>发送<br>
服务器端发送数据常用sendto，指定远端端点名<br>
对接收来的数据作应答，sendto引用的对方端点名利用recvfrom返回得到的端点名</li>
<li>select定时<br>
select可实现同时等待两个事件：收到数据和定时器超时<br>
用time(0)或者gettimefday()获得时间坐标，计算时间间隔 决定是否执行超时后的动作</li>
<li>死锁问题</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[牛客网错题]]></title>
        <id>https://zjy98.github.io/post/niu-ke-wang-cuo-ti/</id>
        <link href="https://zjy98.github.io/post/niu-ke-wang-cuo-ti/">
        </link>
        <updated>2020-06-10T08:08:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="操作系统">操作系统</h1>
<p>1.下列（静态页式管理）内存管理方法不能实现虚存<br>
原因：<br>
页式管理有：<br>
静态页式管理；<br>
动态页式管理；<br>
其中，静态页式管理是在作业或进程执行前，把作业或进程全部装进内存中，如果内存中可用页面数小于请求页面数，该作业或进程等待。<br>
动态页式管理不会把作业或进程一次性全部装进内存，只装入被反复调用或执行的部分，其他部分在执行过程中动态装入。</p>
<p>2.流式文件是指无结构的文件，这种说法正确吗？<br>
正确<br>
原因：文件分为两大类：有结构文件（即记录式文件），无结构文件（即流式文件）。<br>
大量的数据结构和数据库采用有结构文件，大量的源程序，可执行程序，库函数等采用无结构文件　其长度以字节为单位，对流式文件的访问是利用读写指针来指出下一个要访问的字符。<br>
有结构的文件分为定长和不定长两类：<br>
定长又分为：定长记录　变长记录两种<br>
变长记录文件根据文件组织方式的不同又分为：<br>
顺序文件，索引文件，索引顺序文件</p>
<h1 id="linux">Linux</h1>
<p>1.cat -n file1file2 命令的意思是？<br>
把文件file1和file2连在一起，然后输出到屏幕上。-n:合并两个文件</p>
<p>2.下列提法中，不属于ifconfig命令作用范围的是 。<br>
加载网卡到内核中<br>
解答：ifconfig<br>
1.作用：ifconfig用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。<br>
2.格式    ifconfig -interface [options] address<br>
3.主要参数如下：<br>
-interface：指定的网络接口名，如eth0和eth1。<br>
up：激活指定的网络接口卡。<br>
down：关闭指定的网络接口。<br>
broadcast address：设置接口的广播地址。<br>
pointopoint：启用点对点方式。<br>
address：设置指定接口设备的IP地址。<br>
netmask address：设置接口的子网掩码。</p>
<p>3.文件操作的唯一依据是？<br>
文件句柄（文件描述符）</p>
<p>4.建立动态路由需要用到的文件有（）<br>
/etc/gateways<br>
解析：/etc/hosts 设定用户自已的IP与名字的对应表<br>
/etc/gateways 设定路由器<br>
/etc/resolv.conf    设置DNS</p>
<p>5.假如你想计划让系统自动在每个月的第一天早上4点钟执行一个维护工作，以下哪个cron是正确的？<br>
00 4 1 1-12 * /maintenance.pl<br>
解析：计划任务内容格式：分 时 日 月 周  命令/脚本</p>
<p>6.crontab文件由6个域组成，每个域之间用空格分隔，下列哪个排列方式是正确的？<br>
MIN HOUR DAY MONTH DAYOFWEEK COMMAND</p>
<p>7.Linux系统大致启动流程是（）<br>
uEFI-&gt; MBR -&gt; grub -&gt; initrd</p>
<p>8.不算 main 这个进程自身，到底创建了多少个进程啊？19</p>
<pre><code class="language-c">int main(int argc, char* argv[])
{
   fork();
   fork() &amp;&amp; fork() || fork();
   fork();
}
</code></pre>
<p>解析：fork()是一个分叉函数， 返回值： 若成功调用一次则返回两个值，子进程返回0，父进程   返回子进程标记；否则，出错返回-1<br>
每一次fork（）就翻倍；<br>
fork();<br>
fork() &amp;&amp; fork() || fork();<br>
fork();<br>
第一条和第三条分别X2；关键在第二条语句。第二条有 5个分支；<br>
A&amp;&amp;B||C<br>
A为假，跳过B，判断C-----------------------2<br>
A为真，判断B，若B为真，跳过C-----------1<br>
若B为假，判断C  ------------2</p>
<p>故总数为2*（2+1+2）*2=20；减去自己就是19.</p>
<p>9.现在将/目录下的www文件权限改为只有主用户有执行的权限的有<br>
chmod 100 /www<br>
chmod u+x ,g-x,o-x /www<br>
解析：题目要求是只有所有者具有x权限<br>
chmod u+x ,g-x,o-x /www是把go的x权限取代哦，为u增加x权限。原有的权限不变<br>
chmod 100 /www会清空原有权限，只给u一个x权限，也符合题意。</p>
<p>10.在RHEL5系统中使用vi编辑文件时，要将某文本文件第1行到5行的内容复制到文件中的指定位置，以下（  ）操作能实现该功能。（选择二项）<br>
将光标移到第1行，在vi命令模式下输入5yy,然后将光标移到制定位置，按p键<br>
使用末行命令1，5y，然后将光标移到制定位置，按p键<br>
解析：nyy：复制以下n行<br>
n,my：指定n到m行复制<br>
p：在光标下一行粘贴<br>
P（大写）：在光标上一行粘贴（插入）</p>
<p>11.使用useradd创建用户时和主目录相关的参数是()<br>
d.m.n<br>
-p 设定帐号的密码<br>
-d 指定用户的主目录<br>
-m 自动建立用户的主目录<br>
-M 不要自动建立用户的主目录</p>
<h1 id="数组">数组</h1>
<p>1.数组元素的地址计算与数组的存储方式无关。请问这句话的说法是正确的吗？<br>
错误<br>
二维数组存储方式可以分为行优先和列优先俩种，所以数组的地址计算和数组的存储方式有关。</p>
<h1 id="网络基础">网络基础</h1>
<p>1.以下说法不正确的是（）<br>
HTTP请求消息中Css表示初始URL中的主机和端口<br>
原因： HTTP 请求消息中  Host  表示初始 URL 中的主机和端口 。</p>
<p>2.下列哪个任务不是网络操作系统的基本任务？（    ）<br>
明确本地资源与网络资源之间的差异<br>
解析：网络操作系统的基本任务：<br>
1.屏蔽本地资源与网络资源之间的差异<br>
2.为用户提供基本的网络服务功能<br>
3.管理网络系统的共享资源<br>
4.提供网络系统的安全服务</p>
<p>3.https协议默认端口号是8081，iptables既可以根据IP制定策略，也可以根据端口制定策略<br>
0-1023是周知端口号</p>
<p>4.网络接口卡是局域网组网需要的基本部件。网卡一端连接局域网中的计算机，另一端连接局域网的（传输介质）<br>
原因：网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口。-----百度百科<br>
（其实网卡工作在一层和二层？</p>
<p>5.在Web开发中，如何实现会话的跟踪？<br>
四种方法实现会话跟踪：URL重写、隐藏表单域、Cookie、Session<br>
A、隐藏表单域一般是在表单提交时在JSP中声明一个隐藏域，可携带数据到表单提交后的页面。如下：<br>
&lt;input type=&quot;hidden&quot; name=&quot;token&quot; value=&quot;&lt;%=session.getAttribute(&quot;token&quot;) %&gt;&quot;&gt;<br>
B、Http是无状态协议，cookie是客户端保存用户会话数据，用于保存用户会话记录。<br>
C、当客户端浏览器禁用cookie时，只有采用URL复写的方式将sessionId携带在URL的末尾来保存会话记录。<br>
D、session是服务端保存用户数据，生成Session时会默认设置一个cookie值为sessionId的cookie保存到客户端</p>
<h1 id="并发-c">并发、C++</h1>
<p>1.多个线程可同时操作一个数据，为了保证该数据的准确性，可将操作该数据的部分改为:<br>
同步<br>
原因：<br>
同步可以理解为加锁</p>
<h1 id="软件工程">软件工程</h1>
<p>1.下列关于数据库设计的叙述中，正确的是（ ）。<br>
在需求分析阶段建立数据字典<br>
原因：按照规范的设计方法，一个完整的数据库设计一般分为以下六个阶段：<br>
⑴需求分析：分析用户的需求，包括数据、功能和性能需求；<br>
⑵概念结构设计：主要采用E-R模型进行设计，包括画E-R图；<br>
⑶逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；<br>
⑷数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；<br>
⑸数据库的实施：包括编程、测试和试运行；<br>
⑹数据库运行与维护：系统的运行与数据库的日常维护。</p>
<p>2.下面哪些测试属于白盒测试 （ ）。<br>
基本路径测试<br>
逻辑覆盖测试<br>
原因：白盒测试法主要有：逻辑覆盖（语句覆盖、路径覆盖、判定覆盖。判断-条件覆盖、条件-组合覆盖）、基本路径测试<br>
黑盒测试主要的方法有：等价类划分法、边界值分析法、错误推测法、因果图法、决策表法、场景法等。</p>
<p>3.下列关于策略处理规则描述正确的是（）<br>
如果子容器的某个策略被配置，则此配置值会覆盖由其父容器所传递下来的配置值<br>
组策略的配置值是有累加性的<br>
系统是先处理计算机配置，再处理用户配置</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进程间的协作、Socket概述]]></title>
        <id>https://zjy98.github.io/post/jin-cheng-jian-de-xie-zuo/</id>
        <link href="https://zjy98.github.io/post/jin-cheng-jian-de-xie-zuo/">
        </link>
        <updated>2020-06-10T03:57:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="信号灯">信号灯</h1>
<p>UNIX的IPC三样：信号灯、共享内存、消息队列（SEM、SHM、MSG)<br>
信号灯：<br>
控制多进程对共享资源的互斥性访问和进程间同步<br>
策略和机制分离：<br>
UNIX仅提供信号灯机制，访问共享资源的进程自身必须正确使用才能保证正确的互斥和同步<br>
不正确的使用会导致信息访问的不安全和死锁<br>
P操作和V操作：<br>
信号灯机制实现了P操作和V操作，而且比简单的PV操作功能更强<br>
<img src="https://zjy98.github.io/post-images/1591761777085.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1591761855853.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1591761884730.png" alt="" loading="lazy"></p>
<h1 id="共享内存">共享内存</h1>
<p>特点：</p>
<ul>
<li>多个进程共同使用同一段物理内存空间</li>
<li>使用共享内存在多进程间传送数据，速度快，但进程必须自行解决对共享内存访问的互斥和同步问题（例如：使用信号灯通过P/V操作）<br>
应用举例：</li>
<li>数据交换：多进程使用共享内存交换数据（最快的进程间通信方式）</li>
<li>运行监视：协议处理程序把有限状态机和统计信息放入共享内存中<br>
协议处理程序运行过程中可随时启动监视程序，从共享内存中读取数据以窥视当前的状态，了解通信状况<br>
监视程序的启动与终止不影响通信进程，而且这种机制不影响协议处理程序的效率。<br>
<img src="https://zjy98.github.io/post-images/1592149253339.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1592149367085.png" alt="" loading="lazy"></li>
</ul>
<h1 id="内存映射文件">内存映射文件</h1>
<p>传统的访问磁盘文件的模式（磁盘到内存）</p>
<ul>
<li>打开一个文件，然后通过read和write访问文件</li>
</ul>
<p>内存映射（Mrmory Map)方式读写文件</p>
<ul>
<li>现代的Linux和Windows都提供了内存映射方式读写文件的方法</li>
<li>将文件中的一部分连续的区域映射成一段进程虚拟地址空间中的内存<br>
进程获取这段映射内存的指针后，就把这个指针当做普通的数据指针一样引用。修改其中的数据，实际修改了文件，引用其中的数据值，就是读取了文件</li>
<li>访问文件跟内存中的数据访问一样</li>
<li>系统不会为数据文件的内存映射区域分配相同大小的物理内存，而是由页面调度算法自动进行物理内存分配</li>
<li>根据虚拟内存的页面调度算法，按需调入数据文件中的内容，必要时淘汰（可能需要写入）内存页面</li>
</ul>
<p>优点：</p>
<ul>
<li>比使用read和write方式速度更快<br>
这两个系统调用的典型用法：<br>
len=read(fd,buf,nbyte)<br>
len=witr(fd,buf,nbyte)<br>
read需要内核将磁盘数据读入到内核缓冲区，再复制到用户进程的缓冲区中，与write方法类似<br>
内尺寸映射方式是访问文件速度最快的方法</li>
<li>提供了多个独立启动的进程共享内存的一种手段<br>
多个进程都通过指针映射同一个文件的相同区域，实际访问同一段内存区域，这段内存是同一文件区域的内存映射<br>
某进程修改数据，就会导致另一个进程可以访问到的数据发生变化，实现多进程共享内存的另外一种方式<br>
在Windows下就可以通过这种方式实现多进程共享内存<br>
注意：多进程之间访问时的同步和互斥，必须通过信号量等机制保证</li>
</ul>
<h2 id="内存映射文件相关系统调用">内存映射文件相关系统调用</h2>
<p>系统调用mmap<br>
通知系统把哪个文件的哪个区域以何种方式映射<img src="https://zjy98.github.io/post-images/1592150498893.png" alt="" loading="lazy"><br>
mmap的参数：<br>
<img src="https://zjy98.github.io/post-images/1592150537596.png" alt="" loading="lazy"></p>
<h1 id="文件和记录的锁定">文件和记录的锁定</h1>
<p>类似读写者问题<br>
<img src="https://zjy98.github.io/post-images/1592150594141.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1592150714069.png" alt="" loading="lazy"><br>
文件和记录锁定机制<br>
文件可以同时被多个进程访问，需要互斥<br>
（操作系统书中的读写者问题）<br>
使用信号灯机制和共享内存等方法<br>
非常复杂，Linux提供了对文件和记录的锁定机制，用于多进程间对文件的互斥性访问。<br>
术语“记录”：<br>
指的是一个文件中从某一位置开始的连续字节流，Linux提供了对记录锁定的机制，用于锁定文件中的某一部分<br>
可以把一个记录定义为从文件首开始直至文件尾，所以文件锁定实际上是记录锁定的一种特例</p>
<p>共享锁和互斥锁<br>
共享锁（也叫读锁）<br>
多进程读操作可以同时进行，即某一进程读记录时，不排斥其他进程也读该记录，但是排斥任何对该记录的写操作<br>
互斥锁（也叫写锁）<br>
当某进程写记录时，排斥所有其他进程对该记录的读和写<br>
<img src="https://zjy98.github.io/post-images/1592151062717.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1592157929867.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1592157933873.png" alt="" loading="lazy"><br>
用C语言写读写者</p>
<p>错题：<br>
1.使用cat打印出一个有100行数据的文本文件，但只能显示出前50行，后50行被阻塞而迟迟不能显示。出现这种现象的一种可能原因是：其他某进程使用fcntl()系统调用将这个文件的后50行数据上了“写锁”，因为写锁锁定时不允许读导致cat被阻塞，如果该进程上锁类型是“读锁”，那么，cat只是打开文件读，将不会被阻塞（错）<br>
理由：fcntl执行的是“咨询式锁定”不是“强制性锁定”，cat读文件时直接read()并不做fcntl()，不做fcntl()就不会导致cat进程阻塞在“写锁”上</p>
<p>2.Linux设计得非常健壮，一直以运行稳定而著称。当系统中多个进程因为对信号量操作出现不恰当的P操作和V操作将导致死锁时，semop()系统调用将直接返回-1，系统拒绝错误的操作，从而避免死锁的发生（错）<br>
理由：A<br>
“策略和机制相分离”是一个重要的设计思路，当系统不能大包大揽时，系统提供“机制”，把“策略”留给程序员，简化了操作系统的设计，程序员正确操作，应该完成的功能也都能实现。这是一个典型的合理的“甩锅”行为。因特网和Linux设计上都遵循了这样的理念。SUID，bash中的条件判断，四则运算，都是相同的理念，它们简化了自己，仅提供“机制”，把“策略”留给应用程序，不失必备功能。C语言也一样，printf在C语言里也只是个函数，与语言本身无关，你不高兴完全可以设计一个替换它。C语言自己设计得很简单，以至于常用C语言的程序员，不需要查阅任何手册，都能把语法全部准确记下来。C++，你试试？</p>
<p>3.对信号量的P操作有可能导致进程进入阻塞状态，也有可能不进入阻塞状态，但是V操作确定不会导致当前进程进入阻塞状态。（对）<br>
理由：V操作要让当前进程进入阻塞状态，阻塞起来有什么意义？等什么事件？都不需要。所以，V操作不会导致当前进程阻塞，但可以想象，在内核代码里，会导致相关联P操作的进程从“阻塞态”中解除。</p>
<p>4.UDP提供了不可靠服务，所以通信线路误码导致的数据比特被翻转会传递到UDP之上的应用层程序，因此对于一些重要的应用使用UDP通信应增加类似CRC等校验机制。（错）<br>
理由:链路层的校验已经很强了，有线以太网和WiFi都提供了CRC32校验，历数所有链路层协议，只有已被淘汰的SLIP协议没有校验，其他全部有校验。这个是协议体系结构中的安排，把强校验放到链路层，因为链路层一般是硬件实现的，硬件做校验比CPU软件实现开销要小，就算软件实现的PPP over serial line，也有软件查表法计算CRC。所以，链路层可以发现（算然不见得有自动重传来纠正误码）误码。退一步讲，UDP自己也有校验和。UDP校验和是选项，校验和域0，就是没有校验；校验和非零，就采用了算术和校验（这个CPU擅长，但CPU不擅长CRC），若凑巧算术和校验是0，就在校验域填写-1。你可以WireShark看一下，你的UDP都有校验和吗？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深度神经网络DNN]]></title>
        <id>https://zjy98.github.io/post/shen-du-shen-jing-wang-luo-dnn/</id>
        <link href="https://zjy98.github.io/post/shen-du-shen-jing-wang-luo-dnn/">
        </link>
        <updated>2020-06-09T17:48:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="深层神经网络deep-neural-networksdnn">深层神经网络（Deep Neural Networks,DNN)</h1>
<ol>
<li>深度学习定义：一类通过多层非线性变换对高复杂性数据建模算法的集合</li>
<li>DNN定义：一种具备至少一个隐藏层的，利用激活函数去线性化，使用交叉熵作损失函数，利用反向传播优化算法（随机梯度下降算法、批量梯度下降算法）进行学习训练（调整并更新神经元之间的权重）的前馈神经网络。</li>
<li>前向传播算法：利用我们的若干个权重系数矩阵W,偏倚向量b来和输入值向量x进行一系列线性运算和激活运算，从输入层开始，一层层的向后计算，一直到运算到输出层，得到输出结果为值。<br>
<img src="https://zjy98.github.io/post-images/1591725082432.png" alt="" loading="lazy"></li>
<li>激活函数：目的是去线性化，实现非线性分类任务；线性叠加永远是线性，无法处理非线性问题。<br>
<img src="https://zjy98.github.io/post-images/1591725116000.png" alt="" loading="lazy"></li>
<li>SoftMax回归：将神经网络的输出编程一个概率分布，实现交叉熵损失函数<br>
<img src="https://zjy98.github.io/post-images/1591725136519.png" alt="" loading="lazy"></li>
<li>损失函数：刻画前向传播输出与期望值的拟合程度<br>
<img src="https://zjy98.github.io/post-images/1591725165893.png" alt="" loading="lazy"></li>
<li>神经网络优化算法<br>
<img src="https://zjy98.github.io/post-images/1591725187567.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1591725198343.png" alt="" loading="lazy"></li>
<li>学习率的优化：<br>
<img src="https://zjy98.github.io/post-images/1591725224517.png" alt="" loading="lazy"></li>
<li>交叉验证：简单交叉验证（70%-30%分裂数据集），K-折交叉验证，留一交叉验证。</li>
<li>正则化（过拟合问题）：L2-正则化； Dropout；数据增强</li>
<li>滑动平均模型：①滑动平均模型的作用是提高测试值上的健壮性，一个参数变化很大，那势必会影响到测试准确度问题，从他的公式看shadow_var = decay * shadow_var + (1 - decay)* var_new，decay控制着该shadow变量的更新速度，decay越大，那么很明显其值就会越倾向接近于旧值，而decay越小，那么var_new产生的叠加作用就会越强，其结果就会越倾向于远离旧值，那这样波动就很大，通常认为稳定性就不够好当然就不够健壮了<br>
      ②通俗的理解就是“让参数有滑动效果，目的是让参数不是一个常数，而是一个可以变的参数，提高模型的稳定性”</li>
<li>异或问题（XOR问题）:<br>
①如果要利用单层感知器画出一条直线把0和1分开，如下所示的异或问题（分类问题）是做不到的。<br>
②单层感知器无法找到一条直线作为决策边界使 (0,0) 和 (1,1) 在一个区域，而 (1,0) 和 (0,1) 在另一个区域。</li>
<li>网络层数增加带来的问题：<br>
神经网络层数加深，优化函数会越来越容易陷入局部最优解，这个局部最优解离全局最优解也可能会越来越远，同时“梯度消失”现象也会越来越严重。2006年Hinton利用预训练法缓解了局部最优解问题。为了克服“梯度消失”现象，用ReLu、maxout等激活函数代替了sigmoid函数。</li>
<li>卷积神经网络和循环神经网络：CNN是空间上深度增加的神经网络，RNN是时间上深度增加的神经网络。</li>
</ol>
]]></content>
    </entry>
</feed>