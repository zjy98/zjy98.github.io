<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://zjy98.github.io</id>
    <title>给敦敦买炸猪排</title>
    <updated>2020-05-18T16:59:33.812Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://zjy98.github.io"/>
    <link rel="self" href="https://zjy98.github.io/atom.xml"/>
    <subtitle>LOVE YOURSELF</subtitle>
    <logo>https://zjy98.github.io/images/avatar.png</logo>
    <icon>https://zjy98.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 给敦敦买炸猪排</rights>
    <entry>
        <title type="html"><![CDATA[进程控制与进程之间的通信]]></title>
        <id>https://zjy98.github.io/post/jin-cheng-kong-zhi-yu-jin-cheng-zhi-jian-de-tong-xin/</id>
        <link href="https://zjy98.github.io/post/jin-cheng-kong-zhi-yu-jin-cheng-zhi-jian-de-tong-xin/">
        </link>
        <updated>2020-05-17T03:19:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="进程的基本概念和逻辑内存">进程的基本概念和逻辑内存</h1>
<ul>
<li>程序<br>
指令和数据的集合<br>
存放在磁盘上的一个普通文件里<br>
文件的i节点中标位可执行，内容符合系统要求</li>
<li>进程<br>
包括指令段、用户数据段和系统数据段的执行环节<br>
（进程就是程序的一次执行）</li>
<li>进程和程序的关系<br>
程序用于初始化进程的指令段和用户数据段，初始化后，进程和初始它的程序之间无联系<br>
进程运行时磁盘上的程序文件不可修改或删除<br>
同时运行的多个进程可由同一程序初始化得到，进程之间没什么联系内核通过安排它们共享指令段甚至不同程序的进程共享函数库（动态链接）以节省内存，但这种安排对用户来说是透明的</li>
<li>进程的组成部分<br>
四部分：**  指令段、数据段，栈段和系统数据 **<br>
1.指令段：text（从可执行文件中抄来）<br>
程序的CPU指令代码，包括：主程序和子程序编译后的CPU指令代码，以及调用的库函数代码<br>
指令段的大小固定不变，只读<br>
2.用户数据段：（两个来源）程序中或malloc动态申请<br>
·全局变量，静态变量，字符串常数<br>
允许数据段增长和缩小，实现内存的动态分配<br>
系统调用sbrk()允许编程调整数据段的大小（调整单位为页）<br>
内存管理库函数：malloc(),free()<br>
3.用户栈段：（程序执行现场的一部分，保留当前指针）<br>
·程序执行所需要的栈空间，实现函数的调用<br>
用于保存子程序返回地址<br>
在函数和被调函数之间传递参数<br>
函数体内部定义的变量（静态变量除外）<br>
·main函数得到的命令行参数以及环境参数<br>
存放在栈的最底部<br>
main函数运行之前，这些部分就已经被系统初始化<br>
·栈段的动态增长与增长限制（在编译程序编译时设置参数）<br>
4.系统数据段<br>
·上述三部分在进程私有的独立的逻辑地址空间内（CPU用户态访问）<br>
·系统数据段是内核内的数据，每个进程对应一套：包括页表和进程控制块PCB<br>
<img src="https://zjy98.github.io/post-images/1589808827641.png" alt="" loading="lazy"></li>
</ul>
<p>初始化的读写型数据：int a<br>
下面三行从可执行文件中拷贝而来</p>
<p><img src="https://zjy98.github.io/post-images/1589816585649.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589817098948.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589817133888.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589817691042.png" alt="" loading="lazy"></p>
<p>进程的系统数据：<br>
在UINX内核中，含有进程的属性，包括：<br>
页表<br>
进程状态，优先级信息<br>
核心堆栈<br>
当前目录（记录了当前目录的i节点）根目录<br>
打开的文件描述符表<br>
umask值<br>
进程PID,PPID<br>
进程主的实际UID/GID,有效UID/GID<br>
进程组组号</p>
<h2 id="进程pcb被分为user结构和proc结构两部分">进程PCB被分为user结构和proc结构两部分</h2>
<ul>
<li>user结构约5000字节，&lt;sys/user.h&gt;<br>
进程运行时才需要的数据在user结构<br>
核心态堆栈占用了较多空间</li>
<li>proc结构约300字节，&lt;sys/proc.h&gt;<br>
进程不运行时也需要的管理信息存于proc结构</li>
<li>用户程序不能直接存取和修改进程的系统数据</li>
<li>系统调用可用来访问或修改这些属性<br>
chdir umask open close setpgrp getpid getppid</li>
</ul>
<h2 id="进程的基本状态">进程的基本状态</h2>
<p>3个基本状态<br>
进程创建之后，主要有运行状态和睡眠状态（也叫阻塞状态，等待状态，挂起状态等等）<br>
内核总是在分时处理运行状态的进程，而不顾那些睡眠状态 的进程<br>
睡眠状态的进程，在条件满足后转化为运行状态<br>
进程在睡眠时，不占用CPU时间<br>
在编程时，尽量不要让程序处于忙等待状态</p>
<h2 id="进程的调度">进程的调度</h2>
<p>调度优先级：<br>
内核将可运行程序按优先级调度，高优先级进程优先<br>
进程的优先级在不停的变化<br>
处于睡眠状态的进程一旦被叫醒后，被赋予高优先级，以保障人机会话操作和其他外设的响应速度<br>
优先级高：时间片短 优先级低：时间片长<br>
用户程序用nice()系统调用有限地调整优先级<br>
<img src="https://zjy98.github.io/post-images/1589818884183.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589819141064.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589819153633.png" alt="" loading="lazy"></p>
<h2 id="进程的执行时间">进程的执行时间</h2>
<p>进程占用CPU的时间，大部分处于阻塞状态<br>
<img src="https://zjy98.github.io/post-images/1589819294612.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1589819539782.png" alt="" loading="lazy"></p>
<p>多任务系统中，忙等待是不可取的。浪费CPU while循环一直转<br>
<img src="https://zjy98.github.io/post-images/1589820327759.png" alt="" loading="lazy"></p>
<p>课后题：<br>
1.下段程序中变量a,b以及常数120, 250分别存放在进程的哪个内存段中？</p>
<pre><code class="language-c">static int a = 120;
void modify(void)
{
    int b;
    scanf(&quot;%d&quot;, &amp;b);
    a += b + 250;
}
</code></pre>
<p>在main函数运行前，加载程序负责初始化携带初值的可读写型变量a在数据段的初值为120，所以常数120在数据段，它和a是一回事，只是a的初始值而已，而250是编译之后指令的一个操作数，叫“立即数寻址”，也就是说250是一条指令的操作数之一，是一条指令的一部分，存放在指令段</p>
<p>2.int a[N] = { 2 };改为int a[N]<br>
局数组只要是初始化了，无论初始化了一个元素或者全部元素，编译生成可执行文件（即狭义的“程序”）时，会把这个数组的全部内容逐比特记录到可执行文件中，进程启动时分配指定大小空间并把可执行文件中记录的初值初始化它。如果数组未初始化，可执行文件里只需要记录一下这个全局变量有多大就可以了，进程启动时分配指定大小空间并清零。可以尝试把那一行修改为<br>
int a[N] = { 0 };<br>
在现代的Linux中处理得跟未赋初值一样，在早先的Unix中处理得跟有赋初值一样。显然新的处理方法更优。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[强化学习]]></title>
        <id>https://zjy98.github.io/post/qiang-hua-xue-xi/</id>
        <link href="https://zjy98.github.io/post/qiang-hua-xue-xi/">
        </link>
        <updated>2020-05-15T00:24:48.000Z</updated>
        <content type="html"><![CDATA[<p>强化学习：reinforvement learning<br>
是一种“套路”或者“形式”，它可以强化或者鼓励某个人或者某个事物以更高的可能性产生同样的行为。<br>
核心：通过某种手段影响被实验者的 行为，为了实现这个目标，实验者需要构建一个完整的实验环境，通过给与被实验者一定的观测和回报，让其产生实验者想要的结果。<br>
流程：<br>
1.在每一个时刻，环境都处于一种状态<br>
2.智能体将设法得到环境当前状态的观测值<br>
3.智能体根据观测值，结合自己历史的行为准则（一般称为策略）做出行动<br>
4.这个行动会影响环境的状态，使环境发生一定改变。</p>
<p>状态：智能体所处环境的所有信息<br>
观测值：是玩家能看到的一部分信息<br>
两者存在的差异：很多任务中玩家只能看到所处位置附近的信息，而这只占整个地图的一部分，这时状态和观测的差异会对决策产生很大影响，由于每一时刻只能观测到部分信息，玩家需要记住其他区域的信息，才能做更好的全局最优的决策。</p>
<p>特点：<br>
1.不断试错，Agent需要根据回报的多少不断调整自己的策略，从而尽可能多的获得回报<br>
2.长期回报，强化学习的任务通常需要长时间的交互，追求长期分数需要多探探索，多尝试。<br>
衡量指标：<br>
算法的效果‘就散时间’稳定性和泛化性等<br>
学习时间:由于学习和尝试相关，所以学习时间一般也看做探索的次数，如果探索次数较多，一般认为所花的时间也较长。</p>
<p>监督学习：目标是训练一个模型，使模型能根据确定的输入得到对应的输出<br>
强化学习：学习“做什么”即如何把当前的情景映射为动作，才能使得数值化的收益信号最大化。<br>
学习目标的区别：<br>
监督学习：希望模型根据指定的输入得到对应的输出<br>
强化学习：希望agent（也可以想象成模型）根据指定的状态得到使回报最大化的行动<br>
二者都是完成从一个事物到另一个事物的映射</p>
<p>目标明确性的区别：<br>
监督学习：目标更明确，输入对应的是确定的输出，一般一个输入对应一个输出<br>
强化学习：目标没有这么明确。使当前状态获得最大回报的行动可能有很多<br>
比如：俄罗斯方块: 采用监督学习进行训练，模型以每一帧游戏画面为输入，对应的输出必须是确定的； 但实际达到想要的目标的方法不止一种，强化学习更关心回报。</p>
<p>从时间维度上看，二者输出的意义不同<br>
监督学习：主要看重输入和输出的匹配程度，即使存在序列到序列的映射，我们也<br>
希望每一个时刻的输出都能和输入对应上；<br>
强化学习：目标是让回报最大化，但是在与环境交互的过程中，并不是每一个行动<br>
都会获得回报。当我们完成了一次完整的交互后，会得到一个行动序列，这个行动<br>
序列中哪些行动为回报产生了正向的贡献，哪些产生了负向的贡献，有时很难界定。<br>
强化学习和监督学习<br>
棋类游戏：游戏的目标是战胜对方（获得胜利），在得到最终结果之前，Agent可能不会得 到任何回报</p>
<p>总的来说，强化学习相比监督学习有两个优点<br>
（1）定义模型需要的约束更少，影响行动的反馈虽然不及监督学习 直接，却降低了定义问题的难度<br>
（2）更看重行动序列带来的整体回报，而不是单步行动的一致性</p>
<p>有一种学习方法的目标和强化学习一致，都是最大化长期回报，但是 学习方法和监督学习类似，收集大量的单步决策样本，并让模型学习 这些单步决策的逻辑<br>
这种方法被称为“模仿学习”（ Imitation Learning），也被称为 “行为克隆”（ Behavior Cloning），它是模仿学习的一种<br>
模仿学习在一些问题上可以获得比较好的效果，但也存在如下问题<br>
（1）如何收集满足目标的样本？我们必须在某一个领域存在一个专 家，所有的样本通过专家和环境的交互产生。<br>
（2）如何收集大量的样本？如果样本数量不够多，我们很难学习出 好的策略模型。<br>
以上三个问题都不容易解决，因此模仿学习的难度并不小，这才使得 大家把目光集中在强化学习上，希望它能够解决模仿学习无法解决的 问题</p>
<p>参考书：《强化学习精要》</p>
<p>-马尔科夫决策过程MDP<br>
-基于MDP的策略学习<br>
策略迭代，价值迭代。</p>
<p>蛇棋游戏介绍：</p>
<p><img src="https://zjy98.github.io/post-images/1589503323720.png" alt="" loading="lazy"><br>
哪些因素决定了最终获得的分数：<br>
选择什么样的骰子投掷（可由玩家决定）<br>
投掷出的数目大小（玩家无法控制，受环境的随机性控制）<br>
St表示t时刻游戏状态的观测值（棋子所在的位置），用at表示t时刻选择的手法<br>
用一条状态行动链表示<br>
{S0,a0,S1,a1....St-1,at-1,St}<br>
第一种转换由策略决定：<br>
策略是一种映射，将环境的状态值st映射到一个行动集合的概率分布<br>
π=p{at,i|{s0,a0...st}}<br>
行动：玩家根据当前的状态以某种策略选择自认为最好的行动<br>
a*t=argmaxat,ip(at,i|{s0,a0...st})</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序笔记]]></title>
        <id>https://zjy98.github.io/post/wei-xin-xiao-cheng-xu-bi-ji/</id>
        <link href="https://zjy98.github.io/post/wei-xin-xiao-cheng-xu-bi-ji/">
        </link>
        <updated>2020-05-14T16:16:44.000Z</updated>
        <content type="html"><![CDATA[<p><strong>rpx:可以根据屏幕宽度自适应</strong>，规定屏幕宽为750rpx,在ipohne6上，屏幕宽度为375rpx,共有750个像素，则750rpx=375px=750物理像素，1rpx=0.5px=1物理像素（每个设备上换算的不一样）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[写一个简单的操作系统]]></title>
        <id>https://zjy98.github.io/post/xie-yi-ge-jian-dan-de-cao-zuo-xi-tong/</id>
        <link href="https://zjy98.github.io/post/xie-yi-ge-jian-dan-de-cao-zuo-xi-tong/">
        </link>
        <updated>2020-05-12T12:40:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-基本核心模块">一、基本核心模块</h1>
<ul>
<li>
<p>进程管理<br>
1.进程的创建、删除<br>
2.进程的基本属性：进程名、进程时间片、进程优先级<br>
3.支持进程创建与撤销功能，创建后的进程在其整个生命周期可以以PCB形式存在，每个进程用一个PCB表示。<br>
4.进程根据其执行情况在不同队列（就绪队列、阻塞队列、运行队列）间迁移<br>
5.实现单处理器进程调度功能等调度算法实现。<br>
6.管理的进程数目不少于3个，竞争使用的资源可以是CPU、内存、I/O设备等<br>
7.进程可以在初始时刻由系统创建，也可以有其他进程在运行时创建。<br>
8.能够查看各进程状态、各进程队列内容。系统在运行过程中可以显示打印各进程的状态以及有关参数的变化情况，以便观察各个进程的运行过程以及系统的管理过程<br>
9.至少支持1-2个调度算法</p>
</li>
<li>
<p>内存管理</p>
</li>
<li>
<p>文件管理<br>
1.文件的创建、删除<br>
2.文件属性的修改、有关文件目录的操作</p>
</li>
</ul>
<h1 id="二-如何开发">二、如何开发</h1>
<p>我们这次想要做的可 不是这种可执行程序，而是希望能够做到把含有操作系统的CD-ROM或软盘插入电脑，或者将操 作系统装入硬盘后，只要打开电源开关就能自动运行。 为了开发这样的操作系统，我们准备按照如下的步骤来进行。<br>
1、在windows或其他系统上编写源代码<br>
2、用C语言编译器编译源代码，生成机器语言文件<br>
3、对机器语言文件进行加工，生成软盘映像文件<br>
4、将映像文件写入磁盘，作成含操作系统的启动盘</p>
<p>所谓开发操作系统，就是想办法制作一张“含有操作系统的，能够自动启动的 磁盘” 。 这里出现的“映像文件”一词，简单地说就是软盘的备份数据。我们想要把特定的内容写入 磁盘可不是拿块磁铁来在磁盘上晃晃就可以的。所以我们要先做出备份数据，然后将这些备份数 据写入磁盘，这样才能做出符合我们要求的磁盘</p>
<h1 id="三-文件管理">三、文件管理</h1>
<h2 id="文件">文件：</h2>
<ul>
<li>文件是指记录在外存上的具有文件名的一组相关信息的集合。</li>
<li>系统运行时，以进程作为基本单位，用户输入输出时，以文件为基本单位。</li>
<li>可分为有结构文件和无结构文件两种。有结构文件是由若干个相关记录组成，而无结构文件则被看成一个字符流。</li>
<li>有结构的记录式文件<br>
文件构成：由一组相似记录(如:考生信息记录)构成。<br>
记录长度：分为定长和变长。<br>
分类（按记录的组织）：<br>
顺序文件（适用定长记录）<br>
索引文件(变长，建立一张索引表)<br>
直接/哈希文件（键值确定物理地址）</li>
<li>无结构的流式文件<br>
文件构成：由字符流构成。<br>
长度：字节为单位<br>
访问：读写指针,通过穷举搜索的方式访问.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Clustering 聚类]]></title>
        <id>https://zjy98.github.io/post/clustering-ju-lei/</id>
        <link href="https://zjy98.github.io/post/clustering-ju-lei/">
        </link>
        <updated>2020-05-08T00:06:06.000Z</updated>
        <content type="html"><![CDATA[<h1 id="有监督学习和无监督学习">有监督学习和无监督学习</h1>
<p>给定训练集<br>
学习一个函数f:x-&gt;y</p>
<h1 id="应用">应用</h1>
<p>图像分割Images Segmentation，文档分类<br>
market Segmentation<br>
Social Network Analysis</p>
<h1 id="聚类问题描述">聚类问题描述</h1>
<p>聚类分析：发现不同的数据类簇/群组，使得组内的数据具有较高的相似性或相关性，而组间的数据具有较低的相似性或相关性。<br>
<img src="https://zjy98.github.io/post-images/1588896918272.png" alt="" loading="lazy"><br>
无监督，没有正确的标准<br>
类簇划分可以有多个角度：well-sparated clusters  contiguous cluster(有邻接关系)<br>
density-based(基于密度的) center-based(靠距离中心) shared property or conceptual clusters</p>
<h1 id="聚类方法的划分">聚类方法的划分</h1>
<ul>
<li>
<p>划分聚类 partitional clstering<br>
<img src="https://zjy98.github.io/post-images/1588897606556.png" alt="" loading="lazy"></p>
</li>
<li>
<p>层次聚类 hierarchical clustering<br>
<img src="https://zjy98.github.io/post-images/1588897639361.png" alt="" loading="lazy"></p>
</li>
<li>
<p>Exclusive &amp; non-exclusive 排他和非排他</p>
</li>
<li>
<p>Fuzzy &amp; non-fuzzy 模糊和非模糊<br>
weights must sum to 1</p>
</li>
<li>
<p>Partial &amp; complete<br>
In some cases,we only want to cluster some of the data</p>
</li>
<li>
<p>Heterogeneous &amp; homogeneous 异构<br>
Cluster of widely different sizes,shapes,and densities</p>
<h1 id="常用的聚类算法">常用的聚类算法</h1>
<h2 id="k-means">K-means</h2>
<p>1.先确定簇的个数，k<br>
2.假设每个簇都有一个中心点centroid<br>
3.将每个样本点划分到距离它最近的中心点所属的簇中<br>
select K points as the initial centroids<br>
repeat<br>
From K clusters by assigning all points to the closets centroid<br>
Recompute the centroid of each cluster<br>
Until the centroids don't change<br>
<img src="https://zjy98.github.io/post-images/1588898467845.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588898867084.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588898914327.png" alt="" loading="lazy"><br>
如何选取比较好的初始中心点？<br>
1.凭经验选择代表点<br>
2.全部数据随机分成c类，计算每类重心作为初始点<br>
3.用密度法选择代表点<br>
4.将样本随机排序后使用前c个点作为代表点<br>
5.从c-1聚类划分问题的解中产生c聚类划分问题的代表点<br>
对数据没有特别了解，可直接选择2和4方法</p>
</li>
<li>
<p>如何选取K<br>
SSE一般随着k的增大而减小<br>
Limitations of K-means<br>
<img src="https://zjy98.github.io/post-images/1588899870211.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="hierarchical-clustering">Hierarchical clustering</h2>
<p>为数据集输出一个嵌套的、层次化的类别树：dendrogram<br>
树结构记录了簇的合并或拆分<br>
自底向上 agglomerative<br>
自顶向下 divisive<br>
层次凝聚聚类：一种很常用的聚类模型<br>
<img src="https://zjy98.github.io/post-images/1588900023583.png" alt="" loading="lazy"><br>
关键步骤：计算两个簇的相似度<br>
不同的度量两个簇的相似度方法，区分了不同的聚类算法<br>
初始状态：每个点代表一个簇以及一个相似度矩阵proximity matrix<br>
<img src="https://zjy98.github.io/post-images/1588900656204.png" alt="" loading="lazy"><br>
中间状态：经过几次合并操作，得到一些簇以及一个相似度矩阵<br>
<img src="https://zjy98.github.io/post-images/1588900661590.png" alt="" loading="lazy"><br>
合并操作：合并最近的两个簇（c2 and c5)，同事更新相似度矩阵<br>
<img src="https://zjy98.github.io/post-images/1588900667232.png" alt="" loading="lazy"><br>
如何更新相似度矩阵？<br>
Inter-cluster similarity<br>
两个不相交的簇G和H，其间的相似度D（G,H)可以通过点点间的相似度(pairwise similarities) D(i,j),i∈G，j∈H，计算得到<br>
MIN(single linkage)<br>
MAX(complete linkage)<br>
Group Average<br>
<img src="https://zjy98.github.io/post-images/1588900681725.png" alt="" loading="lazy"><br>
single linkage:优势：单链技术可以处理非椭圆形状的簇。不足：对噪音和离群点很敏感<br>
complete linkage:优势：对噪音和离群不敏感 不足：可能使大的簇破裂，偏好球形簇<br>
Group Average:优势：对噪音和极端值影响小 不足：偏好球形簇</p>
<p>** summary **<br>
优点：对类别个数不做假设<br>
通过在不同层的分析，可以获得任意数目的类别<br>
所获得类别可能对应一个有意义的分类体系taxonomies<br>
缺点：缺少目标函数，对噪声和离群点敏感，计算、存储量大</p>
<h2 id="gaussian-mixture-model">Gaussian Mixture Model</h2>
<p>概率聚类模型<br>
将训练数据的概率分布描述为一个混合模型<br>
建模数据的分布<br>
建模类簇划分时的不确定性<br>
一个常用的混合模型：mixtures of Gaussians<br>
<img src="https://zjy98.github.io/post-images/1588900687922.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588900693511.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588900698295.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588900703815.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588900708906.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数]]></title>
        <id>https://zjy98.github.io/post/han-shu/</id>
        <link href="https://zjy98.github.io/post/han-shu/">
        </link>
        <updated>2020-05-07T16:59:56.000Z</updated>
        <content type="html"><![CDATA[<p>语法：<br>
name() {list;}<br>
函数定义完成之后，该函数名作为一个自定义内部命令执行，后面可以调用，调用时函数名后附加0到多个参数，在函数体内部以$1,$2...或$*,$@方式引用。函数体内用内部命令return使函数，0表示成功，非0表示失败。函数内部可以创建和修改变量</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[表达式运算 循环]]></title>
        <id>https://zjy98.github.io/post/biao-da-shi-yun-suan-xun-huan/</id>
        <link href="https://zjy98.github.io/post/biao-da-shi-yun-suan-xun-huan/">
        </link>
        <updated>2020-05-07T07:25:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="表达式运算">表达式运算</h1>
<p>shell不支持除字符串外的数据类型，不支持加减乘除等算数运算和关于字符串的正则表达式运算<br>
需要这些功能，借助于shell之外的可执行程序<br>
/usr/bin/expr实现<br>
有的shell（包括bash)为了提高执行效率，提供内部命令版本的echo,printf,expr,test,[等命令，但这仅仅是一种性能优化措施。只依赖外部命令完全可以实现</p>
<h2 id="expr命令">expr命令</h2>
<p><img src="https://zjy98.github.io/post-images/1588836535381.png" alt="" loading="lazy"><br>
注意：应该有的空格的地方不允许漏掉<br>
应该转义的地方必须加反斜线转义<br>
<img src="https://zjy98.github.io/post-images/1588836695143.png" alt="" loading="lazy"><br>
正则表达式运算：<br>
用法：expr string : pattern<br>
正则表达式pattern匹配字符串string,打印匹配长度<br>
pattern中用\和)括起一部分，能匹配时打印括号内能匹配的部分，否则为空字符串<br>
<img src="https://zjy98.github.io/post-images/1588850083889.png" alt="" loading="lazy"><br>
-w:限时1秒</p>
<h1 id="while循环">while循环</h1>
<p>while condition<br>
do list<br>
done<br>
例如：等待文件 lockfile 消失：<br>
while test -r lockfile<br>
do<br>
sleep 5<br>
done<br>
正确的写法：<br>
while test -r lockfile; do<br>
sleep 5<br>
done<br>
do要和while要加分号<br>
或者全写1行 while test -r lockfile; do sleep 5;done</p>
<h1 id="内部命令eval">内部命令eval</h1>
<p>将程序中输入的或者加工出来的数据作为程序来执行</p>
<ul>
<li>解释和编译</li>
<li>将数据（程序生成的数据或者外部输入的数据）当做程序来执行是只有解释型语言才可能具备的特点，类似C这样的编译型语言无法具备这样的功能（但可以通过动态链接的方式，在程序运行期间不停止程序的运行有限度地变换处理程序）<br>
<img src="https://zjy98.github.io/post-images/1588853579915.png" alt="" loading="lazy"></li>
</ul>
<h1 id="for循环">for循环</h1>
<p>for name in word1 word2...<br>
do list<br>
done<br>
每次从表格里取一个词执行<br>
for name<br>
do list<br>
done<br>
相当于<br>
for name in $1 $2<br>
do list<br>
done<br>
每次取命令行参数1个<br>
seq命令：<br>
for i in <code>seq 1 254\</code><br>
do<br>
ping -c 1 -w 1 192.168.0$i<br>
done<br>
每次取i，1到254<br>
可以直接写为一整行<br>
<img src="https://zjy98.github.io/post-images/1588870464114.png" alt="" loading="lazy"><br>
先判断目录是否存在，在etc这个目录下照rc.d这个子目录，二级目录执行完再执行一级目录，如果rc.d下还有子目录，再执行</p>
<p>break,continue,exit 和C语言类似</p>
<ul>
<li>break:循环结构for/while中使用，中止循环<br>
例：break break2(可以打破两层循环)</li>
<li>continue 提前结束本轮循环</li>
<li>exit:结束脚本程序的执行，退出。exit的参数为该进程执行结束后的返回码<br>
例：exit 1</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[shell逻辑流程控制]]></title>
        <id>https://zjy98.github.io/post/shell-luo-ji-liu-cheng-kong-zhi/</id>
        <link href="https://zjy98.github.io/post/shell-luo-ji-liu-cheng-kong-zhi/">
        </link>
        <updated>2020-05-02T03:12:56.000Z</updated>
        <content type="html"><![CDATA[<h1 id="shell中的逻辑判断">shell中的逻辑判断</h1>
<p>判定一条命令是否执行成功，方法：命令执行的返回码：0表示成功，非0表示失败。可以吧命令执行结束后的返回码理解为出错代码<br>
主函数：<br>
int main（void){...}<br>
int main  (int argc,char **argv){...}<br>
int main  (int argc,char **argv,char **env) {...}<br>
main函数的返回值，如果代码中main()函数没有return一个确定的值，返回码就是随机值，不可用来做条件判断。或者程序调用了exit(code)导致进程终止，exit函数的参数值code。取值0~255。</p>
<h2 id="shell内部变量">shell内部变量$?</h2>
<p>ls -d xyz xyz是一个目录<br>
xyz<br>
echo $?   $?是上一命令的返回码，shell自定义变量<br>
0 若目录存在返回值为0，若不存在返回2<br>
用管道线连接在一起的若干命令，进行条件判断时以最后一个命令执行的返回码为准</p>
<h2 id="复合逻辑">复合逻辑</h2>
<p>用&amp;&amp;或||连结两个命令<br>
可以利用复合逻辑中的短路计算特性实现最简单的条件</p>
<ul>
<li>cmd1&amp;&amp;cmd2<br>
若cmd1执行成功（返回码为0）则执行cmd2,否则不执行cmd2</li>
<li>cmd1||cmd2<br>
若cmd1执行失败（返回码为0）则执行cmd2,否则不执行cmd2<br>
命令true与false<br>
/bin/true<br>
返回码总为0<br>
/bin/false<br>
返回码总不为0<br>
有的shell为了提高效率，将true和false设置为内部命令</li>
</ul>
<h1 id="test及方括号命令">test及方括号命令</h1>
<p>命令test与[<br>
命令/usr/bin/[要求最后一个命令行参数必须为]<br>
除此之外/usr/bin/[与/usr/bin/test功能相同<br>
有的linux系统中/usr/bin/[是一个指向tset的符号连接<br>
注意不要将方括号理解成一个词法符号<br>
举例： test -r /etc/motd<br>
[ -r /etc/motd ]</p>
<ul>
<li>文件特性检测<br>
<img src="https://zjy98.github.io/post-images/1588820228483.png" alt="" loading="lazy"></li>
<li>字符串比较<br>
str1 = str2 字符串相等<br>
str1 != str2 字符串不相等<br>
注意等号和不等号两侧的空格不可少<br>
[ &quot;$a&quot; = &quot;&quot; ] &amp;&amp; echo empty string 注意$a的引号</li>
<li>整数的比较<br>
<img src="https://zjy98.github.io/post-images/1588820402761.png" alt="" loading="lazy"></li>
<li>复合条件<br>
<img src="https://zjy98.github.io/post-images/1588820441597.png" alt="" loading="lazy"></li>
</ul>
<h1 id="命令组合">命令组合</h1>
<p>命令组合类似C语言中的复合语句，组合在一起的几个命令作为一个整体看待：可以集体管道和重定向或者当条件满足时执行若干个命令<br>
判断目录是否存在 统计目录下多少文件 打印当前的工作目录，当前工作目录变成判断的目录<br>
<img src="https://zjy98.github.io/post-images/1588820539948.png" alt="" loading="lazy"><br>
改成（) 当前工作目录不变<br>
<img src="https://zjy98.github.io/post-images/1588820600796.png" alt="" loading="lazy"></p>
<p>{} 在当前shell中执行一组命令<br>
() 在子shell中执行一组命令</p>
<p>(list) 在子shell中执行命令表list<br>
{list} 在当前shell中执行命令表list 注意左花括号后面必须有一个空格<br>
圆括号是shell元字符，花括号不是，它作为一个特殊内部命令处理。所以必须是一行的行首单词<br>
(ls -l;ps)| more<br>
{ ls -l;ps; } | more<br>
<img src="https://zjy98.github.io/post-images/1588834539728.png" alt="" loading="lazy"></p>
<h1 id="条件分支">条件分支</h1>
<p>if 和 case</p>
<h2 id="条件结构if两个或多个分支">条件结构if:两个或多个分支</h2>
<p><img src="https://zjy98.github.io/post-images/1588835015842.png" alt="" loading="lazy"><br>
其中：if/then/elif/else/fi为关键字（内部命令）<br>
<img src="https://zjy98.github.io/post-images/1588835723941.png" alt="" loading="lazy"><br>
date &gt;&gt; /$LOGFILE追加日期到文件里<br>
判断如果文件可写，则把这个文件内容追加到log里，删掉<br>
否则追加no error到LOG<br>
注意：if行不可以和then行直接合并成一行<br>
将两行合并：分号使得一行内可以输入多条命令<br>
if test -r errfile; then<br>
then行可以和cat合并成一行<br>
和C语言不同的是：if的语法中then与else或fi配对，使得不需要花括号这样的命令组合</p>
<h2 id="case结构多条件分支">case结构：多条件分支</h2>
<p><img src="https://zjy98.github.io/post-images/1588836013374.png" alt="" loading="lazy"><br>
;;是一个整体，不能在两个分号之间加空格，也不能用两个连续的空行代替<br>
word与pattern匹配，使用shell的文件名匹配规则<br>
可以使用竖线表示多个模式<br>
word与多个模式匹配时，执行遇到的第一个命令表</p>
<h2 id="shell脚本中的注释">shell脚本中的注释</h2>
<p>shell中使用#号注释<br>
#号出现在一个单词的首部,那么从#号至行尾的所有字符都被忽略</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[元字符]]></title>
        <id>https://zjy98.github.io/post/yuan-zi-fu/</id>
        <link href="https://zjy98.github.io/post/yuan-zi-fu/">
        </link>
        <updated>2020-04-30T02:26:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="shell元字符">shell元字符</h1>
<p><img src="https://zjy98.github.io/post-images/1588216326317.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588216344754.png" alt="" loading="lazy"><br>
反斜线作转义符，取消其后元字符的特殊作用<br>
如果反斜线加在非元字符前面，反斜线和没有一样<br>
find / -size +100 (-name core -o -name*.tmp) -exec rm -f {} ;<br>
<img src="https://zjy98.github.io/post-images/1588216380092.png" alt="" loading="lazy"><br>
取消shell对圆括号的特殊解释 分号前反斜线，<br>
ls -l &gt; file\ list<br>
vi *.c 起名叫*.c<br>
vi 2&gt;&amp;1<br>
单引号和双引号<br>
<img src="https://zjy98.github.io/post-images/1588216408673.png" alt="" loading="lazy"></p>
<p>单引号'<br>
对所括起的任何字符，不作任何解释<br>
系统扫描单引号开始，停止对所有字符的特殊解释，直到再次遇到单引号<br>
<img src="https://zjy98.github.io/post-images/1588214376780.png" alt="" loading="lazy"><br>
单引号是取消所有元字符，双引号取消了大多数元字符，保留了$和`</p>
<h1 id="引号及转义处理">引号及转义处理</h1>
<p>转义问题：在人机交互时，需要准确传达信息，对于特殊字符是其特殊意义还是字面意义<br>
<img src="https://zjy98.github.io/post-images/1588216469133.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588216490996.png" alt="" loading="lazy"><br>
<img src="https://zjy98.github.io/post-images/1588216506365.png" alt="" loading="lazy"><br>
这样的设计为了反撇号的嵌套<br>
<img src="https://zjy98.github.io/post-images/1588214944367.png" alt="" loading="lazy"></p>
<h1 id="应用程序的转义处理与shell的转义处理">应用程序的转义处理与shell的转义处理</h1>
<p>在*.conf文件中找行尾是被单引号括起来的IP地址192.168.x.x的行<br>
<img src="https://zjy98.github.io/post-images/1588216542454.png" alt="" loading="lazy"><br>
双引号里不允许有反斜线，有要加两个</p>
<figure data-type="image" tabindex="1"><img src="https://zjy98.github.io/post-images/1588216166823.png" alt="" loading="lazy"></figure>
<h2 id="反撇号的转义处理">反撇号的转义处理</h2>
<figure data-type="image" tabindex="2"><img src="https://zjy98.github.io/post-images/1588216602639.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[变量]]></title>
        <id>https://zjy98.github.io/post/bian-liang/</id>
        <link href="https://zjy98.github.io/post/bian-liang/">
        </link>
        <updated>2020-04-27T14:20:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="变量的赋值及使用">变量的赋值及使用</h1>
<h2 id="bash变量">bash变量</h2>
<p>存储的的内容：字符串（对数字串来说，不是二进制形式）<br>
在执行过程中其内容可以被修改<br>
赋值及引用：</p>
<ul>
<li>引用addr变量的方法：$ addr或$ {addr}<br>
例如:frp $addr<br>
echo ${addr} A<br>
echo $addr A<br>
命令行中有$ 符的变量引用，shell会先完成变量的替换<br>
赋值时，等号右侧字符串中含有特殊字符：unit=&quot;Beiyou University&quot;  echo $ unit</li>
<li>引用未定义的变量，变量值为空字符串<br>
echo Connect to $ proto Network<br>
porto=TCP/IP<br>
echo Connect to $ proto Network<br>
shell内部开关：set -u当引用一个未定义的变量时，产生一个错误；set +u 当引用一个未定义的变量时，认为是一个空串（默认情形）</li>
<li>命令echo<br>
echo arg1 arg2 arg3...<br>
打印各命令行参数，每两个间用一空格分开，最后打印换行符<br>
不可打印字符（转义）:Linux需加选项-e<br>
echo支持C语言字符串常数描述格式的转义和\c<br>
\b退格 \n换行 \r回车 \t水平制表 \反斜线 \nnn 八进制描述的字符ASCII码 \c打印完毕，不换行<br>
单词之间的分界符一个空格和多个空格一样，要想打印多个空格加双引号<br>
printf用法和C语言类似，用单引号，可以替代echo<br>
\033[H:在屏幕左上角打印</li>
</ul>
<h1 id="在脚本中编辑文件">在脚本中编辑文件</h1>
<p>read:读用户的输入 变量取值的另一种方法<br>
读取用户的而输入并使用输入的信息：read name<br>
/SERVER 找到SERVER这一行<br>
.d 把当前行删掉<br>
i 插入<br>
.插入结束<br>
w 存盘<br>
q退出</p>
<h1 id="环境变量">环境变量</h1>
<p>默认类型：所创建的shell变量，默认为局部变量<br>
内部命令export:局部变量转换为环境变量例如：export proto<br>
shell启动的子进程继承环境变量，不继承局部变量<br>
子进程对环境变量的修改，不影响父进程中同名变量（环境变量的设置，如PATH,CLASSPATH,LANG,如果必要的话放在~/.bashrc中或/etc/profile中）</p>
<p>系统的环境变量<br>
HOME：用户主目录的路径名<br>
PATH：命令查找路径 PATH=/bin:/usr/bin:/etc<br>
与DOS/Windows不同的是：不先搜索当前目录<br>
PATH=./bin:/usr/bin:/etc 先搜索当前目录（危险）<br>
PATH=/bin:/usr/bin:/etc:. 后搜索当前目录（危险）<br>
TERM：终端类型<br>
环境变量PATH的值有特别的含义，一般不会把当前目录.或者上一级目录..作为PATH的分量，主要是出于多用户环境下的安全考虑</p>
<p>环境变量的赋值对某个应用程序，包括java虚拟机及其他的系统软件，有什么影响，与这个AP的设计相关，需要查阅相关的手册<br>
相关命令 set/env<br>
内部命令set列出当前所有变量及其值以及函数定义：包括环境变量和局部变量，函数定义<br>
set | grep ^fname=<br>
外部命令/bin/env 列出环境变量及其值</p>
]]></content>
    </entry>
</feed>